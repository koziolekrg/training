        -:    0:Source:/home/pako/Qt5.6.0/5.6/gcc_64/include/QtCore/qmetatype.h
        -:    0:Graph:/home/pako/Desktop/GitLab/library/media_player_qml_cmake/build/CMakeFiles/music_player.dir/src/mediaplayer.cpp.gcno
        -:    0:Data:/home/pako/Desktop/GitLab/library/media_player_qml_cmake/build/CMakeFiles/music_player.dir/src/mediaplayer.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/****************************************************************************
        -:    2:**
        -:    3:** Copyright (C) 2015 The Qt Company Ltd.
        -:    4:** Copyright (C) 2014 Olivier Goffart <ogoffart@woboq.com>
        -:    5:** Contact: http://www.qt.io/licensing/
        -:    6:**
        -:    7:** This file is part of the QtCore module of the Qt Toolkit.
        -:    8:**
        -:    9:** $QT_BEGIN_LICENSE:LGPL21$
        -:   10:** Commercial License Usage
        -:   11:** Licensees holding valid commercial Qt licenses may use this file in
        -:   12:** accordance with the commercial license agreement provided with the
        -:   13:** Software or, alternatively, in accordance with the terms contained in
        -:   14:** a written agreement between you and The Qt Company. For licensing terms
        -:   15:** and conditions see http://www.qt.io/terms-conditions. For further
        -:   16:** information use the contact form at http://www.qt.io/contact-us.
        -:   17:**
        -:   18:** GNU Lesser General Public License Usage
        -:   19:** Alternatively, this file may be used under the terms of the GNU Lesser
        -:   20:** General Public License version 2.1 or version 3 as published by the Free
        -:   21:** Software Foundation and appearing in the file LICENSE.LGPLv21 and
        -:   22:** LICENSE.LGPLv3 included in the packaging of this file. Please review the
        -:   23:** following information to ensure the GNU Lesser General Public License
        -:   24:** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
        -:   25:** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
        -:   26:**
        -:   27:** As a special exception, The Qt Company gives you certain additional
        -:   28:** rights. These rights are described in The Qt Company LGPL Exception
        -:   29:** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
        -:   30:**
        -:   31:** $QT_END_LICENSE$
        -:   32:**
        -:   33:****************************************************************************/
        -:   34:
        -:   35:#ifndef QMETATYPE_H
        -:   36:#define QMETATYPE_H
        -:   37:
        -:   38:#include <QtCore/qglobal.h>
        -:   39:#include <QtCore/qatomic.h>
        -:   40:#include <QtCore/qbytearray.h>
        -:   41:#include <QtCore/qvarlengtharray.h>
        -:   42:#include <QtCore/qisenum.h>
        -:   43:#include <QtCore/qtypetraits.h>
        -:   44:#ifndef QT_NO_QOBJECT
        -:   45:#include <QtCore/qobjectdefs.h>
        -:   46:#endif
        -:   47:#include <new>
        -:   48:
        -:   49:#include <vector>
        -:   50:#include <list>
        -:   51:#include <map>
        -:   52:
        -:   53:#ifdef Bool
        -:   54:#error qmetatype.h must be included before any header file that defines Bool
        -:   55:#endif
        -:   56:
        -:   57:QT_BEGIN_NAMESPACE
        -:   58:
        -:   59:template <typename T>
        -:   60:struct QMetaTypeId2;
        -:   61:
        -:   62:template <typename T>
        -:   63:inline Q_DECL_CONSTEXPR int qMetaTypeId();
        -:   64:
        -:   65:// F is a tuple: (QMetaType::TypeName, QMetaType::TypeNameID, RealType)
        -:   66:// ### Qt6: reorder the types to match the C++ integral type ranking
        -:   67:#define QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(F)\
        -:   68:    F(Void, 43, void) \
        -:   69:    F(Bool, 1, bool) \
        -:   70:    F(Int, 2, int) \
        -:   71:    F(UInt, 3, uint) \
        -:   72:    F(LongLong, 4, qlonglong) \
        -:   73:    F(ULongLong, 5, qulonglong) \
        -:   74:    F(Double, 6, double) \
        -:   75:    F(Long, 32, long) \
        -:   76:    F(Short, 33, short) \
        -:   77:    F(Char, 34, char) \
        -:   78:    F(ULong, 35, ulong) \
        -:   79:    F(UShort, 36, ushort) \
        -:   80:    F(UChar, 37, uchar) \
        -:   81:    F(Float, 38, float) \
        -:   82:    F(SChar, 40, signed char) \
        -:   83:
        -:   84:#define QT_FOR_EACH_STATIC_PRIMITIVE_POINTER(F)\
        -:   85:    F(VoidStar, 31, void*) \
        -:   86:
        -:   87:#define QT_FOR_EACH_STATIC_CORE_CLASS(F)\
        -:   88:    F(QChar, 7, QChar) \
        -:   89:    F(QString, 10, QString) \
        -:   90:    F(QStringList, 11, QStringList) \
        -:   91:    F(QByteArray, 12, QByteArray) \
        -:   92:    F(QBitArray, 13, QBitArray) \
        -:   93:    F(QDate, 14, QDate) \
        -:   94:    F(QTime, 15, QTime) \
        -:   95:    F(QDateTime, 16, QDateTime) \
        -:   96:    F(QUrl, 17, QUrl) \
        -:   97:    F(QLocale, 18, QLocale) \
        -:   98:    F(QRect, 19, QRect) \
        -:   99:    F(QRectF, 20, QRectF) \
        -:  100:    F(QSize, 21, QSize) \
        -:  101:    F(QSizeF, 22, QSizeF) \
        -:  102:    F(QLine, 23, QLine) \
        -:  103:    F(QLineF, 24, QLineF) \
        -:  104:    F(QPoint, 25, QPoint) \
        -:  105:    F(QPointF, 26, QPointF) \
        -:  106:    F(QRegExp, 27, QRegExp) \
        -:  107:    F(QEasingCurve, 29, QEasingCurve) \
        -:  108:    F(QUuid, 30, QUuid) \
        -:  109:    F(QVariant, 41, QVariant) \
        -:  110:    F(QModelIndex, 42, QModelIndex) \
        -:  111:    F(QRegularExpression, 44, QRegularExpression) \
        -:  112:    F(QJsonValue, 45, QJsonValue) \
        -:  113:    F(QJsonObject, 46, QJsonObject) \
        -:  114:    F(QJsonArray, 47, QJsonArray) \
        -:  115:    F(QJsonDocument, 48, QJsonDocument) \
        -:  116:    F(QPersistentModelIndex, 50, QPersistentModelIndex) \
        -:  117:
        -:  118:#define QT_FOR_EACH_STATIC_CORE_POINTER(F)\
        -:  119:    F(QObjectStar, 39, QObject*)
        -:  120:
        -:  121:#define QT_FOR_EACH_STATIC_CORE_TEMPLATE(F)\
        -:  122:    F(QVariantMap, 8, QVariantMap) \
        -:  123:    F(QVariantList, 9, QVariantList) \
        -:  124:    F(QVariantHash, 28, QVariantHash) \
        -:  125:    F(QByteArrayList, 49, QByteArrayList) \
        -:  126:
        -:  127:#define QT_FOR_EACH_STATIC_GUI_CLASS(F)\
        -:  128:    F(QFont, 64, QFont) \
        -:  129:    F(QPixmap, 65, QPixmap) \
        -:  130:    F(QBrush, 66, QBrush) \
        -:  131:    F(QColor, 67, QColor) \
        -:  132:    F(QPalette, 68, QPalette) \
        -:  133:    F(QIcon, 69, QIcon) \
        -:  134:    F(QImage, 70, QImage) \
        -:  135:    F(QPolygon, 71, QPolygon) \
        -:  136:    F(QRegion, 72, QRegion) \
        -:  137:    F(QBitmap, 73, QBitmap) \
        -:  138:    F(QCursor, 74, QCursor) \
        -:  139:    F(QKeySequence, 75, QKeySequence) \
        -:  140:    F(QPen, 76, QPen) \
        -:  141:    F(QTextLength, 77, QTextLength) \
        -:  142:    F(QTextFormat, 78, QTextFormat) \
        -:  143:    F(QMatrix, 79, QMatrix) \
        -:  144:    F(QTransform, 80, QTransform) \
        -:  145:    F(QMatrix4x4, 81, QMatrix4x4) \
        -:  146:    F(QVector2D, 82, QVector2D) \
        -:  147:    F(QVector3D, 83, QVector3D) \
        -:  148:    F(QVector4D, 84, QVector4D) \
        -:  149:    F(QQuaternion, 85, QQuaternion) \
        -:  150:    F(QPolygonF, 86, QPolygonF) \
        -:  151:
        -:  152:
        -:  153:#define QT_FOR_EACH_STATIC_WIDGETS_CLASS(F)\
        -:  154:    F(QSizePolicy, 121, QSizePolicy) \
        -:  155:
        -:  156:// ### FIXME kill that set
        -:  157:#define QT_FOR_EACH_STATIC_HACKS_TYPE(F)\
        -:  158:    F(QMetaTypeId2<qreal>::MetaType, -1, qreal)
        -:  159:
        -:  160:// F is a tuple: (QMetaType::TypeName, QMetaType::TypeNameID, AliasingType, "RealType")
        -:  161:#define QT_FOR_EACH_STATIC_ALIAS_TYPE(F)\
        -:  162:    F(ULong, -1, ulong, "unsigned long") \
        -:  163:    F(UInt, -1, uint, "unsigned int") \
        -:  164:    F(UShort, -1, ushort, "unsigned short") \
        -:  165:    F(UChar, -1, uchar, "unsigned char") \
        -:  166:    F(LongLong, -1, qlonglong, "long long") \
        -:  167:    F(ULongLong, -1, qulonglong, "unsigned long long") \
        -:  168:    F(SChar, -1, signed char, "qint8") \
        -:  169:    F(UChar, -1, uchar, "quint8") \
        -:  170:    F(Short, -1, short, "qint16") \
        -:  171:    F(UShort, -1, ushort, "quint16") \
        -:  172:    F(Int, -1, int, "qint32") \
        -:  173:    F(UInt, -1, uint, "quint32") \
        -:  174:    F(LongLong, -1, qlonglong, "qint64") \
        -:  175:    F(ULongLong, -1, qulonglong, "quint64") \
        -:  176:    F(QVariantList, -1, QVariantList, "QList<QVariant>") \
        -:  177:    F(QVariantMap, -1, QVariantMap, "QMap<QString,QVariant>") \
        -:  178:    F(QVariantHash, -1, QVariantHash, "QHash<QString,QVariant>") \
        -:  179:    F(QByteArrayList, -1, QByteArrayList, "QList<QByteArray>") \
        -:  180:
        -:  181:#define QT_FOR_EACH_STATIC_TYPE(F)\
        -:  182:    QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(F)\
        -:  183:    QT_FOR_EACH_STATIC_PRIMITIVE_POINTER(F)\
        -:  184:    QT_FOR_EACH_STATIC_CORE_CLASS(F)\
        -:  185:    QT_FOR_EACH_STATIC_CORE_POINTER(F)\
        -:  186:    QT_FOR_EACH_STATIC_CORE_TEMPLATE(F)\
        -:  187:    QT_FOR_EACH_STATIC_GUI_CLASS(F)\
        -:  188:    QT_FOR_EACH_STATIC_WIDGETS_CLASS(F)\
        -:  189:
        -:  190:#define QT_DEFINE_METATYPE_ID(TypeName, Id, Name) \
        -:  191:    TypeName = Id,
        -:  192:
        -:  193:#define QT_FOR_EACH_AUTOMATIC_TEMPLATE_1ARG(F) \
        -:  194:    F(QList) \
        -:  195:    F(QVector) \
        -:  196:    F(QQueue) \
        -:  197:    F(QStack) \
        -:  198:    F(QSet) \
        -:  199:    F(QLinkedList)
        -:  200:
        -:  201:#define QT_FOR_EACH_AUTOMATIC_TEMPLATE_2ARG(F) \
        -:  202:    F(QHash, class) \
        -:  203:    F(QMap, class) \
        -:  204:    F(QPair, struct)
        -:  205:
        -:  206:#define QT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(F) \
        -:  207:    F(QSharedPointer) \
        -:  208:    F(QWeakPointer) \
        -:  209:    F(QPointer)
        -:  210:
        -:  211:class QDataStream;
        -:  212:class QMetaTypeInterface;
        -:  213:struct QMetaObject;
        -:  214:
        -:  215:namespace QtPrivate
        -:  216:{
        -:  217:/*!
        -:  218:    This template is used for implicit conversion from type From to type To.
        -:  219:    \internal
        -:  220:*/
        -:  221:template<typename From, typename To>
        -:  222:To convertImplicit(const From& from)
        -:  223:{
        -:  224:    return from;
        -:  225:}
        -:  226:
        -:  227:#ifndef QT_NO_DEBUG_STREAM
        -:  228:struct AbstractDebugStreamFunction
        -:  229:{
        -:  230:    typedef void (*Stream)(const AbstractDebugStreamFunction *, QDebug&, const void *);
        -:  231:    typedef void (*Destroy)(AbstractDebugStreamFunction *);
        -:  232:    explicit AbstractDebugStreamFunction(Stream s = Q_NULLPTR, Destroy d = Q_NULLPTR)
        -:  233:        : stream(s), destroy(d) {}
        -:  234:    Q_DISABLE_COPY(AbstractDebugStreamFunction)
        -:  235:    Stream stream;
        -:  236:    Destroy destroy;
        -:  237:};
        -:  238:
        -:  239:template<typename T>
        -:  240:struct BuiltInDebugStreamFunction : public AbstractDebugStreamFunction
        -:  241:{
        -:  242:    BuiltInDebugStreamFunction()
        -:  243:        : AbstractDebugStreamFunction(stream, destroy) {}
        -:  244:    static void stream(const AbstractDebugStreamFunction *, QDebug& dbg, const void *r)
        -:  245:    {
        -:  246:        const T *rhs = static_cast<const T *>(r);
        -:  247:        operator<<(dbg, *rhs);
        -:  248:    }
        -:  249:
        -:  250:    static void destroy(AbstractDebugStreamFunction *_this)
        -:  251:    {
        -:  252:        delete static_cast<BuiltInDebugStreamFunction *>(_this);
        -:  253:    }
        -:  254:};
        -:  255:#endif
        -:  256:
        -:  257:struct AbstractComparatorFunction
        -:  258:{
        -:  259:    typedef bool (*LessThan)(const AbstractComparatorFunction *, const void *, const void *);
        -:  260:    typedef bool (*Equals)(const AbstractComparatorFunction *, const void *, const void *);
        -:  261:    typedef void (*Destroy)(AbstractComparatorFunction *);
        -:  262:    explicit AbstractComparatorFunction(LessThan lt = Q_NULLPTR, Equals e = Q_NULLPTR, Destroy d = Q_NULLPTR)
        -:  263:        : lessThan(lt), equals(e), destroy(d) {}
        -:  264:    Q_DISABLE_COPY(AbstractComparatorFunction)
        -:  265:    LessThan lessThan;
        -:  266:    Equals equals;
        -:  267:    Destroy destroy;
        -:  268:};
        -:  269:
        -:  270:template<typename T>
        -:  271:struct BuiltInComparatorFunction : public AbstractComparatorFunction
        -:  272:{
        -:  273:    BuiltInComparatorFunction()
        -:  274:        : AbstractComparatorFunction(lessThan, equals, destroy) {}
        -:  275:    static bool lessThan(const AbstractComparatorFunction *, const void *l, const void *r)
        -:  276:    {
        -:  277:        const T *lhs = static_cast<const T *>(l);
        -:  278:        const T *rhs = static_cast<const T *>(r);
        -:  279:        return *lhs < *rhs;
        -:  280:    }
        -:  281:
        -:  282:    static bool equals(const AbstractComparatorFunction *, const void *l, const void *r)
        -:  283:    {
        -:  284:        const T *lhs = static_cast<const T *>(l);
        -:  285:        const T *rhs = static_cast<const T *>(r);
        -:  286:        return *lhs == *rhs;
        -:  287:    }
        -:  288:
        -:  289:    static void destroy(AbstractComparatorFunction *_this)
        -:  290:    {
        -:  291:        delete static_cast<BuiltInComparatorFunction *>(_this);
        -:  292:    }
        -:  293:};
        -:  294:
        -:  295:template<typename T>
        -:  296:struct BuiltInEqualsComparatorFunction : public AbstractComparatorFunction
        -:  297:{
        -:  298:    BuiltInEqualsComparatorFunction()
        -:  299:        : AbstractComparatorFunction(Q_NULLPTR, equals, destroy) {}
        -:  300:    static bool equals(const AbstractComparatorFunction *, const void *l, const void *r)
        -:  301:    {
        -:  302:        const T *lhs = static_cast<const T *>(l);
        -:  303:        const T *rhs = static_cast<const T *>(r);
        -:  304:        return *lhs == *rhs;
        -:  305:    }
        -:  306:
        -:  307:    static void destroy(AbstractComparatorFunction *_this)
        -:  308:    {
        -:  309:        delete static_cast<BuiltInEqualsComparatorFunction *>(_this);
        -:  310:    }
        -:  311:};
        -:  312:
        -:  313:struct AbstractConverterFunction
        -:  314:{
        -:  315:    typedef bool (*Converter)(const AbstractConverterFunction *, const void *, void*);
        -:  316:    explicit AbstractConverterFunction(Converter c = Q_NULLPTR)
        -:  317:        : convert(c) {}
        -:  318:    Q_DISABLE_COPY(AbstractConverterFunction)
        -:  319:    Converter convert;
        -:  320:};
        -:  321:
        -:  322:template<typename From, typename To>
        -:  323:struct ConverterMemberFunction : public AbstractConverterFunction
        -:  324:{
        -:  325:    explicit ConverterMemberFunction(To(From::*function)() const)
        -:  326:        : AbstractConverterFunction(convert),
        -:  327:          m_function(function) {}
        -:  328:    ~ConverterMemberFunction();
        -:  329:    static bool convert(const AbstractConverterFunction *_this, const void *in, void *out)
        -:  330:    {
        -:  331:        const From *f = static_cast<const From *>(in);
        -:  332:        To *t = static_cast<To *>(out);
        -:  333:        const ConverterMemberFunction *_typedThis =
        -:  334:            static_cast<const ConverterMemberFunction *>(_this);
        -:  335:        *t = (f->*_typedThis->m_function)();
        -:  336:        return true;
        -:  337:    }
        -:  338:
        -:  339:    To(From::* const m_function)() const;
        -:  340:};
        -:  341:
        -:  342:template<typename From, typename To>
        -:  343:struct ConverterMemberFunctionOk : public AbstractConverterFunction
        -:  344:{
        -:  345:    explicit ConverterMemberFunctionOk(To(From::*function)(bool *) const)
        -:  346:        : AbstractConverterFunction(convert),
        -:  347:          m_function(function) {}
        -:  348:    ~ConverterMemberFunctionOk();
        -:  349:    static bool convert(const AbstractConverterFunction *_this, const void *in, void *out)
        -:  350:    {
        -:  351:        const From *f = static_cast<const From *>(in);
        -:  352:        To *t = static_cast<To *>(out);
        -:  353:        bool ok = false;
        -:  354:        const ConverterMemberFunctionOk *_typedThis =
        -:  355:            static_cast<const ConverterMemberFunctionOk *>(_this);
        -:  356:        *t = (f->*_typedThis->m_function)(&ok);
        -:  357:        if (!ok)
        -:  358:            *t = To();
        -:  359:        return ok;
        -:  360:    }
        -:  361:
        -:  362:    To(From::* const m_function)(bool*) const;
        -:  363:};
        -:  364:
        -:  365:template<typename From, typename To, typename UnaryFunction>
        -:  366:struct ConverterFunctor : public AbstractConverterFunction
        -:  367:{
        -:  368:    explicit ConverterFunctor(UnaryFunction function)
        -:  369:        : AbstractConverterFunction(convert),
        -:  370:          m_function(function) {}
        -:  371:    ~ConverterFunctor();
        -:  372:    static bool convert(const AbstractConverterFunction *_this, const void *in, void *out)
        -:  373:    {
        -:  374:        const From *f = static_cast<const From *>(in);
        -:  375:        To *t = static_cast<To *>(out);
        -:  376:        const ConverterFunctor *_typedThis =
        -:  377:            static_cast<const ConverterFunctor *>(_this);
        -:  378:        *t = _typedThis->m_function(*f);
        -:  379:        return true;
        -:  380:    }
        -:  381:
        -:  382:    UnaryFunction m_function;
        -:  383:};
        -:  384:
        -:  385:    template<typename T, bool>
        -:  386:    struct ValueTypeIsMetaType;
        -:  387:    template<typename T, bool>
        -:  388:    struct AssociativeValueTypeIsMetaType;
        -:  389:    template<typename T, bool>
        -:  390:    struct IsMetaTypePair;
        -:  391:    template<typename, typename>
        -:  392:    struct MetaTypeSmartPointerHelper;
        -:  393:}
        -:  394:
        -:  395:class Q_CORE_EXPORT QMetaType {
        -:  396:    enum ExtensionFlag { NoExtensionFlags,
        -:  397:                         CreateEx = 0x1, DestroyEx = 0x2,
        -:  398:                         ConstructEx = 0x4, DestructEx = 0x8,
        -:  399:                         NameEx = 0x10, SizeEx = 0x20,
        -:  400:                         CtorEx = 0x40, DtorEx = 0x80,
        -:  401:                         FlagsEx = 0x100, MetaObjectEx = 0x200
        -:  402:                       };
        -:  403:public:
        -:  404:#ifndef Q_QDOC
        -:  405:    // The code that actually gets compiled.
        -:  406:    enum Type {
        -:  407:        // these are merged with QVariant
        -:  408:        QT_FOR_EACH_STATIC_TYPE(QT_DEFINE_METATYPE_ID)
        -:  409:
        -:  410:        FirstCoreType = Bool,
        -:  411:        LastCoreType = QPersistentModelIndex,
        -:  412:        FirstGuiType = QFont,
        -:  413:        LastGuiType = QPolygonF,
        -:  414:        FirstWidgetsType = QSizePolicy,
        -:  415:        LastWidgetsType = QSizePolicy,
        -:  416:        HighestInternalId = LastWidgetsType,
        -:  417:
        -:  418:        QReal = sizeof(qreal) == sizeof(double) ? Double : Float,
        -:  419:
        -:  420:        UnknownType = 0,
        -:  421:        User = 1024
        -:  422:    };
        -:  423:#else
        -:  424:    // If we are using QDoc it fakes the Type enum looks like this.
        -:  425:    enum Type {
        -:  426:        UnknownType = 0, Bool = 1, Int = 2, UInt = 3, LongLong = 4, ULongLong = 5,
        -:  427:        Double = 6, Long = 32, Short = 33, Char = 34, ULong = 35, UShort = 36,
        -:  428:        UChar = 37, Float = 38,
        -:  429:        VoidStar = 31,
        -:  430:        QChar = 7, QString = 10, QStringList = 11, QByteArray = 12,
        -:  431:        QBitArray = 13, QDate = 14, QTime = 15, QDateTime = 16, QUrl = 17,
        -:  432:        QLocale = 18, QRect = 19, QRectF = 20, QSize = 21, QSizeF = 22,
        -:  433:        QLine = 23, QLineF = 24, QPoint = 25, QPointF = 26, QRegExp = 27,
        -:  434:        QEasingCurve = 29, QUuid = 30, QVariant = 41, QModelIndex = 42,
        -:  435:        QPersistentModelIndex = 50, QRegularExpression = 44,
        -:  436:        QJsonValue = 45, QJsonObject = 46, QJsonArray = 47, QJsonDocument = 48,
        -:  437:        QByteArrayList = 49, QObjectStar = 39, SChar = 40,
        -:  438:        Void = 43,
        -:  439:        QVariantMap = 8, QVariantList = 9, QVariantHash = 28,
        -:  440:        QFont = 64, QPixmap = 65, QBrush = 66, QColor = 67, QPalette = 68,
        -:  441:        QIcon = 69, QImage = 70, QPolygon = 71, QRegion = 72, QBitmap = 73,
        -:  442:        QCursor = 74, QKeySequence = 75, QPen = 76, QTextLength = 77, QTextFormat = 78,
        -:  443:        QMatrix = 79, QTransform = 80, QMatrix4x4 = 81, QVector2D = 82,
        -:  444:        QVector3D = 83, QVector4D = 84, QQuaternion = 85, QPolygonF = 86,
        -:  445:        QSizePolicy = 121,
        -:  446:        User = 1024
        -:  447:    };
        -:  448:#endif
        -:  449:
        -:  450:    enum TypeFlag {
        -:  451:        NeedsConstruction = 0x1,
        -:  452:        NeedsDestruction = 0x2,
        -:  453:        MovableType = 0x4,
        -:  454:        PointerToQObject = 0x8,
        -:  455:        IsEnumeration = 0x10,
        -:  456:        SharedPointerToQObject = 0x20,
        -:  457:        WeakPointerToQObject = 0x40,
        -:  458:        TrackingPointerToQObject = 0x80,
        -:  459:        WasDeclaredAsMetaType = 0x100,
        -:  460:        IsGadget = 0x200
        -:  461:    };
        -:  462:    Q_DECLARE_FLAGS(TypeFlags, TypeFlag)
        -:  463:
        -:  464:    typedef void (*Deleter)(void *);
        -:  465:    typedef void *(*Creator)(const void *);
        -:  466:
        -:  467:    typedef void (*Destructor)(void *);
        -:  468:    typedef void *(*Constructor)(void *, const void *);
        -:  469:
        -:  470:    typedef void (*SaveOperator)(QDataStream &, const void *);
        -:  471:    typedef void (*LoadOperator)(QDataStream &, void *);
        -:  472:#ifndef QT_NO_DATASTREAM
        -:  473:    static void registerStreamOperators(const char *typeName, SaveOperator saveOp,
        -:  474:                                        LoadOperator loadOp);
        -:  475:    static void registerStreamOperators(int type, SaveOperator saveOp,
        -:  476:                                        LoadOperator loadOp);
        -:  477:#endif
        -:  478:    static int registerType(const char *typeName, Deleter deleter,
        -:  479:                            Creator creator);
        -:  480:    static int registerType(const char *typeName, Deleter deleter,
        -:  481:                            Creator creator,
        -:  482:                            Destructor destructor,
        -:  483:                            Constructor constructor,
        -:  484:                            int size,
        -:  485:                            QMetaType::TypeFlags flags,
        -:  486:                            const QMetaObject *metaObject);
        -:  487:    static bool unregisterType(int type);
        -:  488:    static int registerNormalizedType(const QT_PREPEND_NAMESPACE(QByteArray) &normalizedTypeName, Deleter deleter,
        -:  489:                            Creator creator,
        -:  490:                            Destructor destructor,
        -:  491:                            Constructor constructor,
        -:  492:                            int size,
        -:  493:                            QMetaType::TypeFlags flags,
        -:  494:                            const QMetaObject *metaObject);
        -:  495:    static int registerNormalizedType(const QT_PREPEND_NAMESPACE(QByteArray) &normalizedTypeName, Destructor destructor,
        -:  496:                            Constructor constructor,
        -:  497:                            int size,
        -:  498:                            QMetaType::TypeFlags flags,
        -:  499:                            const QMetaObject *metaObject);
        -:  500:    static int registerTypedef(const char *typeName, int aliasId);
        -:  501:    static int registerNormalizedTypedef(const QT_PREPEND_NAMESPACE(QByteArray) &normalizedTypeName, int aliasId);
        -:  502:    static int type(const char *typeName);
        -:  503:#ifndef Q_QDOC
        -:  504:    static int type(const QT_PREPEND_NAMESPACE(QByteArray) &typeName);
        -:  505:#else
        -:  506:    static int type(const QByteArray &typeName);
        -:  507:#endif
        -:  508:    static const char *typeName(int type);
        -:  509:    static int sizeOf(int type);
        -:  510:    static TypeFlags typeFlags(int type);
        -:  511:    static const QMetaObject *metaObjectForType(int type);
        -:  512:    static bool isRegistered(int type);
        -:  513:    static void *create(int type, const void *copy = Q_NULLPTR);
        -:  514:#if QT_DEPRECATED_SINCE(5, 0)
        -:  515:    QT_DEPRECATED static void *construct(int type, const void *copy = Q_NULLPTR)
        -:  516:    { return create(type, copy); }
        -:  517:#endif
        -:  518:    static void destroy(int type, void *data);
        -:  519:    static void *construct(int type, void *where, const void *copy);
        -:  520:    static void destruct(int type, void *where);
        -:  521:
        -:  522:#ifndef QT_NO_DATASTREAM
        -:  523:    static bool save(QDataStream &stream, int type, const void *data);
        -:  524:    static bool load(QDataStream &stream, int type, void *data);
        -:  525:#endif
        -:  526:
        -:  527:    explicit QMetaType(const int type);
        -:  528:    inline ~QMetaType();
        -:  529:
        -:  530:    inline bool isValid() const;
        -:  531:    inline bool isRegistered() const;
        -:  532:    inline int sizeOf() const;
        -:  533:    inline TypeFlags flags() const;
        -:  534:    inline const QMetaObject *metaObject() const;
        -:  535:
        -:  536:    inline void *create(const void *copy = Q_NULLPTR) const;
        -:  537:    inline void destroy(void *data) const;
        -:  538:    inline void *construct(void *where, const void *copy = Q_NULLPTR) const;
        -:  539:    inline void destruct(void *data) const;
        -:  540:
        -:  541:public:
        -:  542:    template<typename T>
        -:  543:    static bool registerComparators()
        -:  544:    {
        -:  545:        Q_STATIC_ASSERT_X((!QMetaTypeId2<T>::IsBuiltIn),
        -:  546:            "QMetaType::registerComparators: The type must be a custom type.");
        -:  547:
        -:  548:        const int typeId = qMetaTypeId<T>();
        -:  549:        static const QtPrivate::BuiltInComparatorFunction<T> f;
        -:  550:        return registerComparatorFunction( &f, typeId);
        -:  551:    }
        -:  552:    template<typename T>
        -:  553:    static bool registerEqualsComparator()
        -:  554:    {
        -:  555:        Q_STATIC_ASSERT_X((!QMetaTypeId2<T>::IsBuiltIn),
        -:  556:            "QMetaType::registerEqualsComparator: The type must be a custom type.");
        -:  557:        const int typeId = qMetaTypeId<T>();
        -:  558:        static const QtPrivate::BuiltInEqualsComparatorFunction<T> f;
        -:  559:        return registerComparatorFunction( &f, typeId);
        -:  560:    }
        -:  561:
        -:  562:    template<typename T>
        -:  563:    static bool hasRegisteredComparators()
        -:  564:    {
        -:  565:        return hasRegisteredComparators(qMetaTypeId<T>());
        -:  566:    }
        -:  567:    static bool hasRegisteredComparators(int typeId);
        -:  568:
        -:  569:
        -:  570:#ifndef QT_NO_DEBUG_STREAM
        -:  571:    template<typename T>
        -:  572:    static bool registerDebugStreamOperator()
        -:  573:    {
        -:  574:        Q_STATIC_ASSERT_X((!QMetaTypeId2<T>::IsBuiltIn),
        -:  575:            "QMetaType::registerDebugStreamOperator: The type must be a custom type.");
        -:  576:
        -:  577:        const int typeId = qMetaTypeId<T>();
        -:  578:        static const QtPrivate::BuiltInDebugStreamFunction<T> f;
        -:  579:        return registerDebugStreamOperatorFunction(&f, typeId);
        -:  580:    }
        -:  581:    template<typename T>
        -:  582:    static bool hasRegisteredDebugStreamOperator()
        -:  583:    {
        -:  584:        return hasRegisteredDebugStreamOperator(qMetaTypeId<T>());
        -:  585:    }
        -:  586:    static bool hasRegisteredDebugStreamOperator(int typeId);
        -:  587:#endif
        -:  588:
        -:  589:    // implicit conversion supported like double -> float
        -:  590:    template<typename From, typename To>
        -:  591:    static bool registerConverter()
        -:  592:    {
        -:  593:        return registerConverter<From, To>(QtPrivate::convertImplicit<From, To>);
        -:  594:    }
        -:  595:
        -:  596:#ifdef Q_QDOC
        -:  597:    static bool registerConverter(MemberFunction function);
        -:  598:    static bool registerConverter(MemberFunctionOk function);
        -:  599:    static bool registerConverter(UnaryFunction function);
        -:  600:#else
        -:  601:    // member function as in "QString QFont::toString() const"
        -:  602:    template<typename From, typename To>
        -:  603:    static bool registerConverter(To(From::*function)() const)
        -:  604:    {
        -:  605:        Q_STATIC_ASSERT_X((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn),
        -:  606:            "QMetaType::registerConverter: At least one of the types must be a custom type.");
        -:  607:
        -:  608:        const int fromTypeId = qMetaTypeId<From>();
        -:  609:        const int toTypeId = qMetaTypeId<To>();
        -:  610:        static const QtPrivate::ConverterMemberFunction<From, To> f(function);
        -:  611:        return registerConverterFunction(&f, fromTypeId, toTypeId);
        -:  612:    }
        -:  613:
        -:  614:    // member function as in "double QString::toDouble(bool *ok = Q_NULLPTR) const"
        -:  615:    template<typename From, typename To>
        -:  616:    static bool registerConverter(To(From::*function)(bool*) const)
        -:  617:    {
        -:  618:        Q_STATIC_ASSERT_X((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn),
        -:  619:            "QMetaType::registerConverter: At least one of the types must be a custom type.");
        -:  620:
        -:  621:        const int fromTypeId = qMetaTypeId<From>();
        -:  622:        const int toTypeId = qMetaTypeId<To>();
        -:  623:        static const QtPrivate::ConverterMemberFunctionOk<From, To> f(function);
        -:  624:        return registerConverterFunction(&f, fromTypeId, toTypeId);
        -:  625:    }
        -:  626:
        -:  627:    // functor or function pointer
        -:  628:    template<typename From, typename To, typename UnaryFunction>
        -:  629:    static bool registerConverter(UnaryFunction function)
        -:  630:    {
        -:  631:        Q_STATIC_ASSERT_X((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn),
        -:  632:            "QMetaType::registerConverter: At least one of the types must be a custom type.");
        -:  633:
        -:  634:        const int fromTypeId = qMetaTypeId<From>();
        -:  635:        const int toTypeId = qMetaTypeId<To>();
        -:  636:        static const QtPrivate::ConverterFunctor<From, To, UnaryFunction> f(function);
        -:  637:        return registerConverterFunction(&f, fromTypeId, toTypeId);
        -:  638:    }
        -:  639:#endif
        -:  640:
        -:  641:    static bool convert(const void *from, int fromTypeId, void *to, int toTypeId);
        -:  642:    static bool compare(const void *lhs, const void *rhs, int typeId, int* result);
        -:  643:    static bool equals(const void *lhs, const void *rhs, int typeId, int* result);
        -:  644:    static bool debugStream(QDebug& dbg, const void *rhs, int typeId);
        -:  645:
        -:  646:    template<typename From, typename To>
        -:  647:    static bool hasRegisteredConverterFunction()
        -:  648:    {
        -:  649:        return hasRegisteredConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
        -:  650:    }
        -:  651:
        -:  652:    static bool hasRegisteredConverterFunction(int fromTypeId, int toTypeId);
        -:  653:
        -:  654:private:
        -:  655:    static QMetaType typeInfo(const int type);
        -:  656:    inline QMetaType(const ExtensionFlag extensionFlags, const QMetaTypeInterface *info,
        -:  657:                     Creator creator,
        -:  658:                     Deleter deleter,
        -:  659:                     SaveOperator saveOp,
        -:  660:                     LoadOperator loadOp,
        -:  661:                     Constructor constructor,
        -:  662:                     Destructor destructor,
        -:  663:                     uint sizeOf,
        -:  664:                     uint theTypeFlags,
        -:  665:                     int typeId,
        -:  666:                     const QMetaObject *metaObject);
        -:  667:    QMetaType(const QMetaType &other);
        -:  668:    QMetaType &operator =(const QMetaType &);
        -:  669:    inline bool isExtended(const ExtensionFlag flag) const { return m_extensionFlags & flag; }
        -:  670:
        -:  671:    // Methods used for future binary compatible extensions
        -:  672:    void ctor(const QMetaTypeInterface *info);
        -:  673:    void dtor();
        -:  674:    uint sizeExtended() const;
        -:  675:    QMetaType::TypeFlags flagsExtended() const;
        -:  676:    const QMetaObject *metaObjectExtended() const;
        -:  677:    void *createExtended(const void *copy = Q_NULLPTR) const;
        -:  678:    void destroyExtended(void *data) const;
        -:  679:    void *constructExtended(void *where, const void *copy = Q_NULLPTR) const;
        -:  680:    void destructExtended(void *data) const;
        -:  681:
        -:  682:    static bool registerComparatorFunction(const QtPrivate::AbstractComparatorFunction *f, int type);
        -:  683:#ifndef QT_NO_DEBUG_STREAM
        -:  684:    static bool registerDebugStreamOperatorFunction(const QtPrivate::AbstractDebugStreamFunction *f, int type);
        -:  685:#endif
        -:  686:
        -:  687:// ### Qt6: FIXME: Remove the special Q_CC_MSVC handling, it was introduced to maintain BC.
        -:  688:#if !defined(Q_NO_TEMPLATE_FRIENDS) && !defined(Q_CC_MSVC)
        -:  689:#ifndef Q_QDOC
        -:  690:    template<typename, bool> friend struct QtPrivate::ValueTypeIsMetaType;
        -:  691:    template<typename, typename> friend struct QtPrivate::ConverterMemberFunction;
        -:  692:    template<typename, typename> friend struct QtPrivate::ConverterMemberFunctionOk;
        -:  693:    template<typename, typename, typename> friend struct QtPrivate::ConverterFunctor;
        -:  694:    template<typename, bool> friend struct QtPrivate::AssociativeValueTypeIsMetaType;
        -:  695:    template<typename, bool> friend struct QtPrivate::IsMetaTypePair;
        -:  696:    template<typename, typename> friend struct QtPrivate::MetaTypeSmartPointerHelper;
        -:  697:#endif
        -:  698:#else
        -:  699:public:
        -:  700:#endif
        -:  701:    static bool registerConverterFunction(const QtPrivate::AbstractConverterFunction *f, int from, int to);
        -:  702:    static void unregisterConverterFunction(int from, int to);
        -:  703:private:
        -:  704:
        -:  705:    Creator m_creator_unused;
        -:  706:    Deleter m_deleter_unused;
        -:  707:    SaveOperator m_saveOp;
        -:  708:    LoadOperator m_loadOp;
        -:  709:    Constructor m_constructor;
        -:  710:    Destructor m_destructor;
        -:  711:    void *m_extension; // space reserved for future use
        -:  712:    uint m_size;
        -:  713:    uint m_typeFlags;
        -:  714:    uint m_extensionFlags;
        -:  715:    int m_typeId;
        -:  716:    const QMetaObject *m_metaObject;
        -:  717:};
        -:  718:
        -:  719:#undef QT_DEFINE_METATYPE_ID
        -:  720:
        -:  721:Q_DECLARE_OPERATORS_FOR_FLAGS(QMetaType::TypeFlags)
        -:  722:
        -:  723:namespace QtPrivate {
        -:  724:
        -:  725:template<typename From, typename To>
        -:  726:ConverterMemberFunction<From, To>::~ConverterMemberFunction()
        -:  727:{
        -:  728:    QMetaType::unregisterConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
        -:  729:}
        -:  730:template<typename From, typename To>
        -:  731:ConverterMemberFunctionOk<From, To>::~ConverterMemberFunctionOk()
        -:  732:{
        -:  733:    QMetaType::unregisterConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
        -:  734:}
        -:  735:template<typename From, typename To, typename UnaryFunction>
        -:  736:ConverterFunctor<From, To, UnaryFunction>::~ConverterFunctor()
        -:  737:{
        -:  738:    QMetaType::unregisterConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
        -:  739:}
        -:  740:
        -:  741:}
        -:  742:
        -:  743:#define QT_METATYPE_PRIVATE_DECLARE_TYPEINFO(C, F)  \
        -:  744:    }                                               \
        -:  745:    Q_DECLARE_TYPEINFO(QtMetaTypePrivate:: C, (F)); \
        -:  746:    namespace QtMetaTypePrivate {
        -:  747:
        -:  748:namespace QtMetaTypePrivate {
        -:  749:template <typename T, bool Accepted = true>
        -:  750:struct QMetaTypeFunctionHelper {
        -:  751:    static void Destruct(void *t)
        -:  752:    {
        -:  753:        Q_UNUSED(t) // Silence MSVC that warns for POD types.
        -:  754:        static_cast<T*>(t)->~T();
        -:  755:    }
        -:  756:
        -:  757:    static void *Construct(void *where, const void *t)
        -:  758:    {
        -:  759:        if (t)
        -:  760:            return new (where) T(*static_cast<const T*>(t));
        -:  761:        return new (where) T;
        -:  762:    }
        -:  763:#ifndef QT_NO_DATASTREAM
        -:  764:    static void Save(QDataStream &stream, const void *t)
        -:  765:    {
        -:  766:        stream << *static_cast<const T*>(t);
        -:  767:    }
        -:  768:
        -:  769:    static void Load(QDataStream &stream, void *t)
        -:  770:    {
        -:  771:        stream >> *static_cast<T*>(t);
        -:  772:    }
        -:  773:#endif // QT_NO_DATASTREAM
        -:  774:};
        -:  775:
        -:  776:template <typename T>
        -:  777:struct QMetaTypeFunctionHelper<T, /* Accepted */ false> {
        -:  778:    static void Destruct(void *) {}
        -:  779:    static void *Construct(void *, const void *) { return Q_NULLPTR; }
        -:  780:#ifndef QT_NO_DATASTREAM
        -:  781:    static void Save(QDataStream &, const void *) {}
        -:  782:    static void Load(QDataStream &, void *) {}
        -:  783:#endif // QT_NO_DATASTREAM
        -:  784:};
        -:  785:template <>
        -:  786:struct QMetaTypeFunctionHelper<void, /* Accepted */ true>
        -:  787:        : public QMetaTypeFunctionHelper<void, /* Accepted */ false>
        -:  788:{};
        -:  789:
        -:  790:struct VariantData
        -:  791:{
        -:  792:    VariantData(const int metaTypeId_,
        -:  793:                const void *data_,
        -:  794:                const uint flags_)
        -:  795:      : metaTypeId(metaTypeId_)
        -:  796:      , data(data_)
        -:  797:      , flags(flags_)
        -:  798:    {
        -:  799:    }
        -:  800:    VariantData(const VariantData &other)
        -:  801:        : metaTypeId(other.metaTypeId), data(other.data), flags(other.flags){}
        -:  802:    const int metaTypeId;
        -:  803:    const void *data;
        -:  804:    const uint flags;
        -:  805:private:
        -:  806:    // copy constructor allowed to be implicit to silence level 4 warning from MSVC
        -:  807:    VariantData &operator=(const VariantData &) Q_DECL_EQ_DELETE;
        -:  808:};
        -:  809:
        -:  810:template<typename const_iterator>
        -:  811:struct IteratorOwnerCommon
        -:  812:{
        -:  813:    static void assign(void **ptr, const_iterator iterator)
        -:  814:    {
        -:  815:        *ptr = new const_iterator(iterator);
        -:  816:    }
        -:  817:    static void assign(void **ptr, void * const * src)
        -:  818:    {
        -:  819:        *ptr = new const_iterator(*static_cast<const_iterator*>(*src));
        -:  820:    }
        -:  821:
        -:  822:    static void advance(void **iterator, int step)
        -:  823:    {
        -:  824:        const_iterator &it = *static_cast<const_iterator*>(*iterator);
        -:  825:        std::advance(it, step);
        -:  826:    }
        -:  827:
        -:  828:    static void destroy(void **ptr)
        -:  829:    {
        -:  830:        delete static_cast<const_iterator*>(*ptr);
        -:  831:    }
        -:  832:
        -:  833:    static bool equal(void * const *it, void * const *other)
        -:  834:    {
        -:  835:        return *static_cast<const_iterator*>(*it) == *static_cast<const_iterator*>(*other);
        -:  836:    }
        -:  837:};
        -:  838:
        -:  839:template<typename const_iterator>
        -:  840:struct IteratorOwner : IteratorOwnerCommon<const_iterator>
        -:  841:{
        -:  842:    static const void *getData(void * const *iterator)
        -:  843:    {
        -:  844:        return &**static_cast<const_iterator*>(*iterator);
        -:  845:    }
        -:  846:
        -:  847:    static const void *getData(const_iterator it)
        -:  848:    {
        -:  849:        return &*it;
        -:  850:    }
        -:  851:};
        -:  852:
        -:  853:struct Q_CORE_EXPORT VectorBoolElements
        -:  854:{
        -:  855:  static const bool true_element;
        -:  856:  static const bool false_element;
        -:  857:};
        -:  858:
        -:  859:template<>
        -:  860:struct IteratorOwner<std::vector<bool>::const_iterator> : IteratorOwnerCommon<std::vector<bool>::const_iterator>
        -:  861:{
        -:  862:public:
        -:  863:    static const void *getData(void * const *iterator)
        -:  864:    {
        -:  865:        return **static_cast<std::vector<bool>::const_iterator*>(*iterator) ?
        -:  866:            &VectorBoolElements::true_element : &VectorBoolElements::false_element;
        -:  867:    }
        -:  868:
        -:  869:    static const void *getData(const std::vector<bool>::const_iterator& it)
        -:  870:    {
        -:  871:        return *it ? &VectorBoolElements::true_element : &VectorBoolElements::false_element;
        -:  872:    }
        -:  873:};
        -:  874:
        -:  875:template<typename value_type>
        -:  876:struct IteratorOwner<const value_type*>
        -:  877:{
        -:  878:private:
        -:  879:    // We need to disable typed overloads of assign() and getData() if the value_type
        -:  880:    // is void* to avoid overloads conflicts. We do it by injecting unaccessible Dummy
        -:  881:    // type as part of the overload signature.
        -:  882:    struct Dummy {};
        -:  883:    typedef typename QtPrivate::if_<QtPrivate::is_same<value_type, void*>::value, Dummy, value_type>::type value_type_OR_Dummy;
        -:  884:public:
        -:  885:    static void assign(void **ptr, const value_type_OR_Dummy *iterator )
        -:  886:    {
        -:  887:        *ptr = const_cast<value_type*>(iterator);
        -:  888:    }
        -:  889:    static void assign(void **ptr, void * const * src)
        -:  890:    {
        -:  891:        *ptr = static_cast<value_type*>(*src);
        -:  892:    }
        -:  893:
        -:  894:    static void advance(void **iterator, int step)
        -:  895:    {
        -:  896:        value_type *it = static_cast<value_type*>(*iterator);
        -:  897:        std::advance(it, step);
        -:  898:        *iterator = it;
        -:  899:    }
        -:  900:
        -:  901:    static void destroy(void **)
        -:  902:    {
        -:  903:    }
        -:  904:
        -:  905:    static const void *getData(void * const *iterator)
        -:  906:    {
        -:  907:        return *iterator;
        -:  908:    }
        -:  909:
        -:  910:    static const void *getData(const value_type_OR_Dummy *it)
        -:  911:    {
        -:  912:        return it;
        -:  913:    }
        -:  914:
        -:  915:    static bool equal(void * const *it, void * const *other)
        -:  916:    {
        -:  917:        return static_cast<value_type*>(*it) == static_cast<value_type*>(*other);
        -:  918:    }
        -:  919:};
        -:  920:
        -:  921:enum IteratorCapability
        -:  922:{
        -:  923:    ForwardCapability = 1,
        -:  924:    BiDirectionalCapability = 2,
        -:  925:    RandomAccessCapability = 4
        -:  926:};
        -:  927:
        -:  928:template<typename T, typename Category = typename std::iterator_traits<typename T::const_iterator>::iterator_category>
        -:  929:struct CapabilitiesImpl;
        -:  930:
        -:  931:template<typename T>
        -:  932:struct CapabilitiesImpl<T, std::forward_iterator_tag>
        -:  933:{ enum { IteratorCapabilities = ForwardCapability }; };
        -:  934:template<typename T>
        -:  935:struct CapabilitiesImpl<T, std::bidirectional_iterator_tag>
        -:  936:{ enum { IteratorCapabilities = BiDirectionalCapability | ForwardCapability }; };
        -:  937:template<typename T>
        -:  938:struct CapabilitiesImpl<T, std::random_access_iterator_tag>
        -:  939:{ enum { IteratorCapabilities = RandomAccessCapability | BiDirectionalCapability | ForwardCapability }; };
        -:  940:
        -:  941:template<typename T>
        -:  942:struct ContainerAPI : CapabilitiesImpl<T>
        -:  943:{
        -:  944:    static int size(const T *t) { return int(std::distance(t->begin(), t->end())); }
        -:  945:};
        -:  946:
        -:  947:template<typename T>
        -:  948:struct ContainerAPI<QList<T> > : CapabilitiesImpl<QList<T> >
        -:  949:{ static int size(const QList<T> *t) { return t->size(); } };
        -:  950:
        -:  951:template<typename T>
        -:  952:struct ContainerAPI<QVector<T> > : CapabilitiesImpl<QVector<T> >
        -:  953:{ static int size(const QVector<T> *t) { return t->size(); } };
        -:  954:
        -:  955:template<typename T>
        -:  956:struct ContainerAPI<std::vector<T> > : CapabilitiesImpl<std::vector<T> >
        -:  957:{ static int size(const std::vector<T> *t) { return int(t->size()); } };
        -:  958:
        -:  959:template<typename T>
        -:  960:struct ContainerAPI<std::list<T> > : CapabilitiesImpl<std::list<T> >
        -:  961:{ static int size(const std::list<T> *t) { return int(t->size()); } };
        -:  962:
        -:  963:class QSequentialIterableImpl
        -:  964:{
        -:  965:public:
        -:  966:    const void * _iterable;
        -:  967:    void *_iterator;
        -:  968:    int _metaType_id;
        -:  969:    uint _metaType_flags;
        -:  970:    uint _iteratorCapabilities;
        -:  971:    typedef int(*sizeFunc)(const void *p);
        -:  972:    typedef const void * (*atFunc)(const void *p, int);
        -:  973:    typedef void (*moveIteratorFunc)(const void *p, void **);
        -:  974:    typedef void (*advanceFunc)(void **p, int);
        -:  975:    typedef VariantData (*getFunc)( void * const *p, int metaTypeId, uint flags);
        -:  976:    typedef void (*destroyIterFunc)(void **p);
        -:  977:    typedef bool (*equalIterFunc)(void * const *p, void * const *other);
        -:  978:    typedef void (*copyIterFunc)(void **, void * const *);
        -:  979:
        -:  980:    sizeFunc _size;
        -:  981:    atFunc _at;
        -:  982:    moveIteratorFunc _moveToBegin;
        -:  983:    moveIteratorFunc _moveToEnd;
        -:  984:    advanceFunc _advance;
        -:  985:    getFunc _get;
        -:  986:    destroyIterFunc _destroyIter;
        -:  987:    equalIterFunc _equalIter;
        -:  988:    copyIterFunc _copyIter;
        -:  989:
        -:  990:    template<class T>
        -:  991:    static int sizeImpl(const void *p)
        -:  992:    { return ContainerAPI<T>::size(static_cast<const T*>(p)); }
        -:  993:
        -:  994:    template<class T>
        -:  995:    static const void* atImpl(const void *p, int idx)
        -:  996:    {
        -:  997:        typename T::const_iterator i = static_cast<const T*>(p)->begin();
        -:  998:        std::advance(i, idx);
        -:  999:        return IteratorOwner<typename T::const_iterator>::getData(i);
        -: 1000:    }
        -: 1001:
        -: 1002:    template<class T>
        -: 1003:    static void moveToBeginImpl(const void *container, void **iterator)
        -: 1004:    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->begin()); }
        -: 1005:
        -: 1006:    template<class T>
        -: 1007:    static void moveToEndImpl(const void *container, void **iterator)
        -: 1008:    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->end()); }
        -: 1009:
        -: 1010:    template<class T>
        -: 1011:    static VariantData getImpl(void * const *iterator, int metaTypeId, uint flags)
        -: 1012:    { return VariantData(metaTypeId, IteratorOwner<typename T::const_iterator>::getData(iterator), flags); }
        -: 1013:
        -: 1014:public:
        -: 1015:    template<class T> QSequentialIterableImpl(const T*p)
        -: 1016:      : _iterable(p)
        -: 1017:      , _iterator(Q_NULLPTR)
        -: 1018:      , _metaType_id(qMetaTypeId<typename T::value_type>())
        -: 1019:      , _metaType_flags(QTypeInfo<typename T::value_type>::isPointer)
        -: 1020:      , _iteratorCapabilities(ContainerAPI<T>::IteratorCapabilities)
        -: 1021:      , _size(sizeImpl<T>)
        -: 1022:      , _at(atImpl<T>)
        -: 1023:      , _moveToBegin(moveToBeginImpl<T>)
        -: 1024:      , _moveToEnd(moveToEndImpl<T>)
        -: 1025:      , _advance(IteratorOwner<typename T::const_iterator>::advance)
        -: 1026:      , _get(getImpl<T>)
        -: 1027:      , _destroyIter(IteratorOwner<typename T::const_iterator>::destroy)
        -: 1028:      , _equalIter(IteratorOwner<typename T::const_iterator>::equal)
        -: 1029:      , _copyIter(IteratorOwner<typename T::const_iterator>::assign)
        -: 1030:    {
        -: 1031:    }
        -: 1032:
        -: 1033:    QSequentialIterableImpl()
        -: 1034:      : _iterable(Q_NULLPTR)
        -: 1035:      , _iterator(Q_NULLPTR)
        -: 1036:      , _metaType_id(QMetaType::UnknownType)
        -: 1037:      , _metaType_flags(0)
        -: 1038:      , _iteratorCapabilities(0)
        -: 1039:      , _size(Q_NULLPTR)
        -: 1040:      , _at(Q_NULLPTR)
        -: 1041:      , _moveToBegin(Q_NULLPTR)
        -: 1042:      , _moveToEnd(Q_NULLPTR)
        -: 1043:      , _advance(Q_NULLPTR)
        -: 1044:      , _get(Q_NULLPTR)
        -: 1045:      , _destroyIter(Q_NULLPTR)
        -: 1046:      , _equalIter(Q_NULLPTR)
        -: 1047:      , _copyIter(Q_NULLPTR)
        -: 1048:    {
        -: 1049:    }
        -: 1050:
        -: 1051:    inline void moveToBegin() { _moveToBegin(_iterable, &_iterator); }
        -: 1052:    inline void moveToEnd() { _moveToEnd(_iterable, &_iterator); }
        -: 1053:    inline bool equal(const QSequentialIterableImpl&other) const { return _equalIter(&_iterator, &other._iterator); }
        -: 1054:    inline QSequentialIterableImpl &advance(int i) {
        -: 1055:      Q_ASSERT(i > 0 || _iteratorCapabilities & BiDirectionalCapability);
        -: 1056:      _advance(&_iterator, i);
        -: 1057:      return *this;
        -: 1058:    }
        -: 1059:
        -: 1060:    inline VariantData getCurrent() const { return _get(&_iterator, _metaType_id, _metaType_flags); }
        -: 1061:
        -: 1062:    VariantData at(int idx) const
        -: 1063:    { return VariantData(_metaType_id, _at(_iterable, idx), _metaType_flags); }
        -: 1064:
        -: 1065:    int size() const { Q_ASSERT(_iterable); return _size(_iterable); }
        -: 1066:
        -: 1067:    inline void destroyIter() { _destroyIter(&_iterator); }
        -: 1068:
        -: 1069:    void copy(const QSequentialIterableImpl &other)
        -: 1070:    {
        -: 1071:      *this = other;
        -: 1072:      _copyIter(&_iterator, &other._iterator);
        -: 1073:    }
        -: 1074:};
        -: 1075:QT_METATYPE_PRIVATE_DECLARE_TYPEINFO(QSequentialIterableImpl, Q_MOVABLE_TYPE)
        -: 1076:
        -: 1077:template<typename From>
        -: 1078:struct QSequentialIterableConvertFunctor
        -: 1079:{
        -: 1080:    QSequentialIterableImpl operator()(const From &f) const
        -: 1081:    {
        -: 1082:        return QSequentialIterableImpl(&f);
        -: 1083:    }
        -: 1084:};
        -: 1085:}
        -: 1086:
        -: 1087:namespace QtMetaTypePrivate {
        -: 1088:template<typename T, bool = QtPrivate::is_same<typename T::const_iterator::value_type, typename T::mapped_type>::value>
        -: 1089:struct AssociativeContainerAccessor
        -: 1090:{
        -: 1091:    static const typename T::key_type& getKey(const typename T::const_iterator &it)
        -: 1092:    {
        -: 1093:        return it.key();
        -: 1094:    }
        -: 1095:
        -: 1096:    static const typename T::mapped_type& getValue(const typename T::const_iterator &it)
        -: 1097:    {
        -: 1098:        return it.value();
        -: 1099:    }
        -: 1100:};
        -: 1101:
        -: 1102:template<typename T, bool = QtPrivate::is_same<typename T::const_iterator::value_type, std::pair<const typename T::key_type, typename T::mapped_type> >::value>
        -: 1103:struct StlStyleAssociativeContainerAccessor;
        -: 1104:
        -: 1105:template<typename T>
        -: 1106:struct StlStyleAssociativeContainerAccessor<T, true>
        -: 1107:{
        -: 1108:    static const typename T::key_type& getKey(const typename T::const_iterator &it)
        -: 1109:    {
        -: 1110:        return it->first;
        -: 1111:    }
        -: 1112:
        -: 1113:    static const typename T::mapped_type& getValue(const typename T::const_iterator &it)
        -: 1114:    {
        -: 1115:        return it->second;
        -: 1116:    }
        -: 1117:};
        -: 1118:
        -: 1119:template<typename T>
        -: 1120:struct AssociativeContainerAccessor<T, false> : public StlStyleAssociativeContainerAccessor<T>
        -: 1121:{
        -: 1122:};
        -: 1123:
        -: 1124:class QAssociativeIterableImpl
        -: 1125:{
        -: 1126:public:
        -: 1127:    const void *_iterable;
        -: 1128:    void *_iterator;
        -: 1129:    int _metaType_id_key;
        -: 1130:    uint _metaType_flags_key;
        -: 1131:    int _metaType_id_value;
        -: 1132:    uint _metaType_flags_value;
        -: 1133:    typedef int(*sizeFunc)(const void *p);
        -: 1134:    typedef void (*findFunc)(const void *container, const void *p, void **iterator);
        -: 1135:    typedef void (*beginFunc)(const void *p, void **);
        -: 1136:    typedef void (*advanceFunc)(void **p, int);
        -: 1137:    typedef VariantData (*getFunc)(void * const *p, int metaTypeId, uint flags);
        -: 1138:    typedef void (*destroyIterFunc)(void **p);
        -: 1139:    typedef bool (*equalIterFunc)(void * const *p, void * const *other);
        -: 1140:    typedef void (*copyIterFunc)(void **, void * const *);
        -: 1141:
        -: 1142:    sizeFunc _size;
        -: 1143:    findFunc _find;
        -: 1144:    beginFunc _begin;
        -: 1145:    beginFunc _end;
        -: 1146:    advanceFunc _advance;
        -: 1147:    getFunc _getKey;
        -: 1148:    getFunc _getValue;
        -: 1149:    destroyIterFunc _destroyIter;
        -: 1150:    equalIterFunc _equalIter;
        -: 1151:    copyIterFunc _copyIter;
        -: 1152:
        -: 1153:    template<class T>
        -: 1154:    static int sizeImpl(const void *p)
        -: 1155:    { return int(std::distance(static_cast<const T*>(p)->begin(),
        -: 1156:                               static_cast<const T*>(p)->end())); }
        -: 1157:
        -: 1158:    template<class T>
        -: 1159:    static void findImpl(const void *container, const void *p, void **iterator)
        -: 1160:    { IteratorOwner<typename T::const_iterator>::assign(iterator,
        -: 1161:                                                        static_cast<const T*>(container)->find(*static_cast<const typename T::key_type*>(p))); }
        -: 1162:
        -: 1163:    template<class T>
        -: 1164:    static void advanceImpl(void **p, int step)
        -: 1165:    { std::advance(*static_cast<typename T::const_iterator*>(*p), step); }
        -: 1166:
        -: 1167:    template<class T>
        -: 1168:    static void beginImpl(const void *container, void **iterator)
        -: 1169:    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->begin()); }
        -: 1170:
        -: 1171:    template<class T>
        -: 1172:    static void endImpl(const void *container, void **iterator)
        -: 1173:    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->end()); }
        -: 1174:
        -: 1175:    template<class T>
        -: 1176:    static VariantData getKeyImpl(void * const *iterator, int metaTypeId, uint flags)
        -: 1177:    { return VariantData(metaTypeId, &AssociativeContainerAccessor<T>::getKey(*static_cast<typename T::const_iterator*>(*iterator)), flags); }
        -: 1178:
        -: 1179:    template<class T>
        -: 1180:    static VariantData getValueImpl(void * const *iterator, int metaTypeId, uint flags)
        -: 1181:    { return VariantData(metaTypeId, &AssociativeContainerAccessor<T>::getValue(*static_cast<typename T::const_iterator*>(*iterator)), flags); }
        -: 1182:
        -: 1183:public:
        -: 1184:    template<class T> QAssociativeIterableImpl(const T*p)
        -: 1185:      : _iterable(p)
        -: 1186:      , _metaType_id_key(qMetaTypeId<typename T::key_type>())
        -: 1187:      , _metaType_flags_key(QTypeInfo<typename T::key_type>::isPointer)
        -: 1188:      , _metaType_id_value(qMetaTypeId<typename T::mapped_type>())
        -: 1189:      , _metaType_flags_value(QTypeInfo<typename T::mapped_type>::isPointer)
        -: 1190:      , _size(sizeImpl<T>)
        -: 1191:      , _find(findImpl<T>)
        -: 1192:      , _begin(beginImpl<T>)
        -: 1193:      , _end(endImpl<T>)
        -: 1194:      , _advance(advanceImpl<T>)
        -: 1195:      , _getKey(getKeyImpl<T>)
        -: 1196:      , _getValue(getValueImpl<T>)
        -: 1197:      , _destroyIter(IteratorOwner<typename T::const_iterator>::destroy)
        -: 1198:      , _equalIter(IteratorOwner<typename T::const_iterator>::equal)
        -: 1199:      , _copyIter(IteratorOwner<typename T::const_iterator>::assign)
        -: 1200:    {
        -: 1201:    }
        -: 1202:
        -: 1203:    QAssociativeIterableImpl()
        -: 1204:      : _iterable(Q_NULLPTR)
        -: 1205:      , _metaType_id_key(QMetaType::UnknownType)
        -: 1206:      , _metaType_flags_key(0)
        -: 1207:      , _metaType_id_value(QMetaType::UnknownType)
        -: 1208:      , _metaType_flags_value(0)
        -: 1209:      , _size(Q_NULLPTR)
        -: 1210:      , _find(Q_NULLPTR)
        -: 1211:      , _begin(Q_NULLPTR)
        -: 1212:      , _end(Q_NULLPTR)
        -: 1213:      , _advance(Q_NULLPTR)
        -: 1214:      , _getKey(Q_NULLPTR)
        -: 1215:      , _getValue(Q_NULLPTR)
        -: 1216:      , _destroyIter(Q_NULLPTR)
        -: 1217:      , _equalIter(Q_NULLPTR)
        -: 1218:      , _copyIter(Q_NULLPTR)
        -: 1219:    {
        -: 1220:    }
        -: 1221:
        -: 1222:    inline void begin() { _begin(_iterable, &_iterator); }
        -: 1223:    inline void end() { _end(_iterable, &_iterator); }
        -: 1224:    inline bool equal(const QAssociativeIterableImpl&other) const { return _equalIter(&_iterator, &other._iterator); }
        -: 1225:    inline QAssociativeIterableImpl &advance(int i) { _advance(&_iterator, i); return *this; }
        -: 1226:
        -: 1227:    inline void destroyIter() { _destroyIter(&_iterator); }
        -: 1228:
        -: 1229:    inline VariantData getCurrentKey() const { return _getKey(&_iterator, _metaType_id_key, _metaType_flags_value); }
        -: 1230:    inline VariantData getCurrentValue() const { return _getValue(&_iterator, _metaType_id_value, _metaType_flags_value); }
        -: 1231:
        -: 1232:    inline void find(const VariantData &key)
        -: 1233:    { _find(_iterable, key.data, &_iterator); }
        -: 1234:
        -: 1235:    int size() const { Q_ASSERT(_iterable); return _size(_iterable); }
        -: 1236:
        -: 1237:    void copy(const QAssociativeIterableImpl &other)
        -: 1238:    {
        -: 1239:      *this = other;
        -: 1240:      _copyIter(&_iterator, &other._iterator);
        -: 1241:    }
        -: 1242:};
        -: 1243:QT_METATYPE_PRIVATE_DECLARE_TYPEINFO(QAssociativeIterableImpl, Q_MOVABLE_TYPE)
        -: 1244:
        -: 1245:template<typename From>
        -: 1246:struct QAssociativeIterableConvertFunctor
        -: 1247:{
        -: 1248:    QAssociativeIterableImpl operator()(const From& f) const
        -: 1249:    {
        -: 1250:        return QAssociativeIterableImpl(&f);
        -: 1251:    }
        -: 1252:};
        -: 1253:
        -: 1254:class QPairVariantInterfaceImpl
        -: 1255:{
        -: 1256:    const void *_pair;
        -: 1257:    int _metaType_id_first;
        -: 1258:    uint _metaType_flags_first;
        -: 1259:    int _metaType_id_second;
        -: 1260:    uint _metaType_flags_second;
        -: 1261:
        -: 1262:    typedef VariantData (*getFunc)(const void * const *p, int metaTypeId, uint flags);
        -: 1263:
        -: 1264:    getFunc _getFirst;
        -: 1265:    getFunc _getSecond;
        -: 1266:
        -: 1267:    template<class T>
        -: 1268:    static VariantData getFirstImpl(const void * const *pair, int metaTypeId, uint flags)
        -: 1269:    { return VariantData(metaTypeId, &static_cast<const T*>(*pair)->first, flags); }
        -: 1270:    template<class T>
        -: 1271:    static VariantData getSecondImpl(const void * const *pair, int metaTypeId, uint flags)
        -: 1272:    { return VariantData(metaTypeId, &static_cast<const T*>(*pair)->second, flags); }
        -: 1273:
        -: 1274:public:
        -: 1275:    template<class T> QPairVariantInterfaceImpl(const T*p)
        -: 1276:      : _pair(p)
        -: 1277:      , _metaType_id_first(qMetaTypeId<typename T::first_type>())
        -: 1278:      , _metaType_flags_first(QTypeInfo<typename T::first_type>::isPointer)
        -: 1279:      , _metaType_id_second(qMetaTypeId<typename T::second_type>())
        -: 1280:      , _metaType_flags_second(QTypeInfo<typename T::second_type>::isPointer)
        -: 1281:      , _getFirst(getFirstImpl<T>)
        -: 1282:      , _getSecond(getSecondImpl<T>)
        -: 1283:    {
        -: 1284:    }
        -: 1285:
        -: 1286:    QPairVariantInterfaceImpl()
        -: 1287:      : _pair(Q_NULLPTR)
        -: 1288:      , _metaType_id_first(QMetaType::UnknownType)
        -: 1289:      , _metaType_flags_first(0)
        -: 1290:      , _metaType_id_second(QMetaType::UnknownType)
        -: 1291:      , _metaType_flags_second(0)
        -: 1292:      , _getFirst(Q_NULLPTR)
        -: 1293:      , _getSecond(Q_NULLPTR)
        -: 1294:    {
        -: 1295:    }
        -: 1296:
        -: 1297:    inline VariantData first() const { return _getFirst(&_pair, _metaType_id_first, _metaType_flags_first); }
        -: 1298:    inline VariantData second() const { return _getSecond(&_pair, _metaType_id_second, _metaType_flags_second); }
        -: 1299:};
        -: 1300:QT_METATYPE_PRIVATE_DECLARE_TYPEINFO(QPairVariantInterfaceImpl, Q_MOVABLE_TYPE)
        -: 1301:
        -: 1302:template<typename From>
        -: 1303:struct QPairVariantInterfaceConvertFunctor;
        -: 1304:
        -: 1305:template<typename T, typename U>
        -: 1306:struct QPairVariantInterfaceConvertFunctor<QPair<T, U> >
        -: 1307:{
        -: 1308:    QPairVariantInterfaceImpl operator()(const QPair<T, U>& f) const
        -: 1309:    {
        -: 1310:        return QPairVariantInterfaceImpl(&f);
        -: 1311:    }
        -: 1312:};
        -: 1313:
        -: 1314:template<typename T, typename U>
        -: 1315:struct QPairVariantInterfaceConvertFunctor<std::pair<T, U> >
        -: 1316:{
        -: 1317:    QPairVariantInterfaceImpl operator()(const std::pair<T, U>& f) const
        -: 1318:    {
        -: 1319:        return QPairVariantInterfaceImpl(&f);
        -: 1320:    }
        -: 1321:};
        -: 1322:
        -: 1323:}
        -: 1324:
        -: 1325:class QObject;
        -: 1326:class QWidget;
        -: 1327:
        -: 1328:#define QT_FORWARD_DECLARE_SHARED_POINTER_TYPES_ITER(Name) \
        -: 1329:    template <class T> class Name; \
        -: 1330:
        -: 1331:QT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(QT_FORWARD_DECLARE_SHARED_POINTER_TYPES_ITER)
        -: 1332:
        -: 1333:namespace QtPrivate
        -: 1334:{
        -: 1335:    template<typename T>
        -: 1336:    struct IsPointerToTypeDerivedFromQObject
        -: 1337:    {
        -: 1338:        enum { Value = false };
        -: 1339:    };
        -: 1340:
        -: 1341:    // Specialize to avoid sizeof(void) warning
        -: 1342:    template<>
        -: 1343:    struct IsPointerToTypeDerivedFromQObject<void*>
        -: 1344:    {
        -: 1345:        enum { Value = false };
        -: 1346:    };
        -: 1347:    template<>
        -: 1348:    struct IsPointerToTypeDerivedFromQObject<const void*>
        -: 1349:    {
        -: 1350:        enum { Value = false };
        -: 1351:    };
        -: 1352:    template<>
        -: 1353:    struct IsPointerToTypeDerivedFromQObject<QObject*>
        -: 1354:    {
        -: 1355:        enum { Value = true };
        -: 1356:    };
        -: 1357:
        -: 1358:    template<typename T>
        -: 1359:    struct IsPointerToTypeDerivedFromQObject<T*>
        -: 1360:    {
        -: 1361:        typedef qint8 yes_type;
        -: 1362:        typedef qint64 no_type;
        -: 1363:
        -: 1364:#ifndef QT_NO_QOBJECT
        -: 1365:        static yes_type checkType(QObject* );
        -: 1366:#endif
        -: 1367:        static no_type checkType(...);
        -: 1368:        Q_STATIC_ASSERT_X(sizeof(T), "Type argument of Q_DECLARE_METATYPE(T*) must be fully defined");
        -: 1369:        enum { Value = sizeof(checkType(static_cast<T*>(Q_NULLPTR))) == sizeof(yes_type) };
        -: 1370:    };
        -: 1371:
        -: 1372:    template<typename T, typename Enable = void>
        -: 1373:    struct IsGadgetHelper { enum { Value = false }; };
        -: 1374:
        -: 1375:    template<typename T>
        -: 1376:    struct IsGadgetHelper<T, typename T::QtGadgetHelper>
        -: 1377:    {
        -: 1378:        template <typename X>
        -: 1379:        static char checkType(void (X::*)());
        -: 1380:        static void *checkType(void (T::*)());
        -: 1381:        enum { Value =  sizeof(checkType(&T::qt_check_for_QGADGET_macro)) == sizeof(void *) };
        -: 1382:    };
        -: 1383:
        -: 1384:
        -: 1385:QT_WARNING_PUSH
        -: 1386:// In C++03 mode, clang consider local or unnamed type and throw a warning instead of ignoring them
        -: 1387:QT_WARNING_DISABLE_CLANG("-Wunnamed-type-template-args")
        -: 1388:QT_WARNING_DISABLE_CLANG("-Wlocal-type-template-args")
        -: 1389:    template<typename T> char qt_getEnumMetaObject(const T&);
        -: 1390:
        -: 1391:    template<typename T>
        -: 1392:    struct IsQEnumHelper {
        -: 1393:        static const T &declval();
        -: 1394:        // If the type was declared with Q_ENUM, the friend qt_getEnumMetaObject() declared in the
        -: 1395:        // Q_ENUM macro will be chosen by ADL, and the return type will be QMetaObject*.
        -: 1396:        // Otherwise the chosen overload will be the catch all template function
        -: 1397:        // qt_getEnumMetaObject(T) which returns 'char'
        -: 1398:        enum { Value = sizeof(qt_getEnumMetaObject(declval())) == sizeof(QMetaObject*) };
        -: 1399:    };
        -: 1400:    template<> struct IsQEnumHelper<void> { enum { Value = false }; };
        -: 1401:QT_WARNING_POP
        -: 1402:
        -: 1403:    template<typename T, typename Enable = void>
        -: 1404:    struct MetaObjectForType
        -: 1405:    {
        -: 1406:        static inline const QMetaObject *value() { return Q_NULLPTR; }
        -: 1407:    };
        -: 1408:    template<>
        -: 1409:    struct MetaObjectForType<void>
        -: 1410:    {
        -: 1411:        static inline const QMetaObject *value() { return Q_NULLPTR; }
        -: 1412:    };
        -: 1413:    template<typename T>
        -: 1414:    struct MetaObjectForType<T*, typename QEnableIf<IsPointerToTypeDerivedFromQObject<T*>::Value>::Type>
        -: 1415:    {
        -: 1416:        static inline const QMetaObject *value() { return &T::staticMetaObject; }
        -: 1417:    };
        -: 1418:    template<typename T>
        -: 1419:    struct MetaObjectForType<T, typename QEnableIf<IsGadgetHelper<T>::Value>::Type>
        -: 1420:    {
        -: 1421:        static inline const QMetaObject *value() { return &T::staticMetaObject; }
        -: 1422:    };
        -: 1423:    template<typename T>
        -: 1424:    struct MetaObjectForType<T, typename QEnableIf<IsQEnumHelper<T>::Value>::Type >
        -: 1425:    {
        -: 1426:        static inline const QMetaObject *value() { return qt_getEnumMetaObject(T()); }
        -: 1427:    };
        -: 1428:
        -: 1429:    template<typename T>
        -: 1430:    struct IsSharedPointerToTypeDerivedFromQObject
        -: 1431:    {
        -: 1432:        enum { Value = false };
        -: 1433:    };
        -: 1434:
        -: 1435:    template<typename T>
        -: 1436:    struct IsSharedPointerToTypeDerivedFromQObject<QSharedPointer<T> > : IsPointerToTypeDerivedFromQObject<T*>
        -: 1437:    {
        -: 1438:    };
        -: 1439:
        -: 1440:    template<typename T>
        -: 1441:    struct IsWeakPointerToTypeDerivedFromQObject
        -: 1442:    {
        -: 1443:        enum { Value = false };
        -: 1444:    };
        -: 1445:
        -: 1446:    template<typename T>
        -: 1447:    struct IsWeakPointerToTypeDerivedFromQObject<QWeakPointer<T> > : IsPointerToTypeDerivedFromQObject<T*>
        -: 1448:    {
        -: 1449:    };
        -: 1450:
        -: 1451:    template<typename T>
        -: 1452:    struct IsTrackingPointerToTypeDerivedFromQObject
        -: 1453:    {
        -: 1454:        enum { Value = false };
        -: 1455:    };
        -: 1456:
        -: 1457:    template<typename T>
        -: 1458:    struct IsTrackingPointerToTypeDerivedFromQObject<QPointer<T> >
        -: 1459:    {
        -: 1460:        enum { Value = true };
        -: 1461:    };
        -: 1462:
        -: 1463:    template<typename T>
        -: 1464:    struct IsSequentialContainer
        -: 1465:    {
        -: 1466:        enum { Value = false };
        -: 1467:    };
        -: 1468:
        -: 1469:    template<typename T>
        -: 1470:    struct IsAssociativeContainer
        -: 1471:    {
        -: 1472:        enum { Value = false };
        -: 1473:    };
        -: 1474:
        -: 1475:    template<typename T, bool = QtPrivate::IsSequentialContainer<T>::Value>
        -: 1476:    struct SequentialContainerConverterHelper
        -: 1477:    {
        -: 1478:        static bool registerConverter(int)
        -: 1479:        {
        -: 1480:            return false;
        -: 1481:        }
        -: 1482:    };
        -: 1483:
        -: 1484:    template<typename T, bool = QMetaTypeId2<typename T::value_type>::Defined>
        -: 1485:    struct ValueTypeIsMetaType
        -: 1486:    {
        -: 1487:        static bool registerConverter(int)
        -: 1488:        {
        -: 1489:            return false;
        -: 1490:        }
        -: 1491:    };
        -: 1492:
        -: 1493:    template<typename T>
        -: 1494:    struct SequentialContainerConverterHelper<T, true> : ValueTypeIsMetaType<T>
        -: 1495:    {
        -: 1496:    };
        -: 1497:
        -: 1498:    template<typename T, bool = QtPrivate::IsAssociativeContainer<T>::Value>
        -: 1499:    struct AssociativeContainerConverterHelper
        -: 1500:    {
        -: 1501:        static bool registerConverter(int)
        -: 1502:        {
        -: 1503:            return false;
        -: 1504:        }
        -: 1505:    };
        -: 1506:
        -: 1507:    template<typename T, bool = QMetaTypeId2<typename T::mapped_type>::Defined>
        -: 1508:    struct AssociativeValueTypeIsMetaType
        -: 1509:    {
        -: 1510:        static bool registerConverter(int)
        -: 1511:        {
        -: 1512:            return false;
        -: 1513:        }
        -: 1514:    };
        -: 1515:
        -: 1516:    template<typename T, bool = QMetaTypeId2<typename T::key_type>::Defined>
        -: 1517:    struct KeyAndValueTypeIsMetaType
        -: 1518:    {
        -: 1519:        static bool registerConverter(int)
        -: 1520:        {
        -: 1521:            return false;
        -: 1522:        }
        -: 1523:    };
        -: 1524:
        -: 1525:    template<typename T>
        -: 1526:    struct KeyAndValueTypeIsMetaType<T, true> : AssociativeValueTypeIsMetaType<T>
        -: 1527:    {
        -: 1528:    };
        -: 1529:
        -: 1530:    template<typename T>
        -: 1531:    struct AssociativeContainerConverterHelper<T, true> : KeyAndValueTypeIsMetaType<T>
        -: 1532:    {
        -: 1533:    };
        -: 1534:
        -: 1535:    template<typename T, bool = QMetaTypeId2<typename T::first_type>::Defined
        -: 1536:                                && QMetaTypeId2<typename T::second_type>::Defined>
        -: 1537:    struct IsMetaTypePair
        -: 1538:    {
        -: 1539:        static bool registerConverter(int)
        -: 1540:        {
        -: 1541:            return false;
        -: 1542:        }
        -: 1543:    };
        -: 1544:
        -: 1545:    template<typename T>
        -: 1546:    struct IsMetaTypePair<T, true>
        -: 1547:    {
        -: 1548:        inline static bool registerConverter(int id);
        -: 1549:    };
        -: 1550:
        -: 1551:    template<typename T>
        -: 1552:    struct IsPair
        -: 1553:    {
        -: 1554:        static bool registerConverter(int)
        -: 1555:        {
        -: 1556:            return false;
        -: 1557:        }
        -: 1558:    };
        -: 1559:    template<typename T, typename U>
        -: 1560:    struct IsPair<QPair<T, U> > : IsMetaTypePair<QPair<T, U> > {};
        -: 1561:    template<typename T, typename U>
        -: 1562:    struct IsPair<std::pair<T, U> > : IsMetaTypePair<std::pair<T, U> > {};
        -: 1563:
        -: 1564:    template<typename T>
        -: 1565:    struct MetaTypePairHelper : IsPair<T> {};
        -: 1566:
        -: 1567:    template<typename T, typename = void>
        -: 1568:    struct MetaTypeSmartPointerHelper
        -: 1569:    {
        -: 1570:        static bool registerConverter(int) { return false; }
        -: 1571:    };
        -: 1572:
        -: 1573:    Q_CORE_EXPORT bool isBuiltinType(const QByteArray &type);
        -: 1574:} // namespace QtPrivate
        -: 1575:
        -: 1576:template <typename T, int =
        -: 1577:    QtPrivate::IsPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::PointerToQObject :
        -: 1578:    QtPrivate::IsGadgetHelper<T>::Value                    ? QMetaType::IsGadget :
        -: 1579:    QtPrivate::IsQEnumHelper<T>::Value                     ? QMetaType::IsEnumeration : 0>
        -: 1580:struct QMetaTypeIdQObject
        -: 1581:{
        -: 1582:    enum {
        -: 1583:        Defined = 0
        -: 1584:    };
        -: 1585:};
        -: 1586:
        -: 1587:template <typename T>
        -: 1588:struct QMetaTypeId : public QMetaTypeIdQObject<T>
        -: 1589:{
        -: 1590:};
        -: 1591:
        -: 1592:template <typename T>
        -: 1593:struct QMetaTypeId2
        -: 1594:{
        -: 1595:    enum { Defined = QMetaTypeId<T>::Defined, IsBuiltIn=false };
        -: 1596:    static inline Q_DECL_CONSTEXPR int qt_metatype_id() { return QMetaTypeId<T>::qt_metatype_id(); }
        -: 1597:};
        -: 1598:
        -: 1599:template <typename T>
        -: 1600:struct QMetaTypeId2<const T&> : QMetaTypeId2<T> {};
        -: 1601:
        -: 1602:template <typename T>
        -: 1603:struct QMetaTypeId2<T&> { enum {Defined = false }; };
        -: 1604:
        -: 1605:namespace QtPrivate {
        -: 1606:    template <typename T, bool Defined = QMetaTypeId2<T>::Defined>
        -: 1607:    struct QMetaTypeIdHelper {
    #####: 1608:        static inline Q_DECL_CONSTEXPR int qt_metatype_id()
    #####: 1609:        { return QMetaTypeId2<T>::qt_metatype_id(); }
        -: 1610:    };
        -: 1611:    template <typename T> struct QMetaTypeIdHelper<T, false> {
        -: 1612:        static inline Q_DECL_CONSTEXPR int qt_metatype_id()
        -: 1613:        { return -1; }
        -: 1614:    };
        -: 1615:
        -: 1616:#ifndef Q_COMPILER_VARIADIC_TEMPLATES
        -: 1617:    // Function pointers don't derive from QObject
        -: 1618:    template <class Result> struct IsPointerToTypeDerivedFromQObject<Result(*)()> { enum { Value = false }; };
        -: 1619:    template <class Result, class Arg0> struct IsPointerToTypeDerivedFromQObject<Result(*)(Arg0)> { enum { Value = false }; };
        -: 1620:    template <class Result, class Arg0, class Arg1> struct IsPointerToTypeDerivedFromQObject<Result(*)(Arg0, Arg1)> { enum { Value = false }; };
        -: 1621:    template <class Result, class Arg0, class Arg1, class Arg2> struct IsPointerToTypeDerivedFromQObject<Result(*)(Arg0, Arg1, Arg2)> { enum { Value = false }; };
        -: 1622:#else
        -: 1623:    template <typename Result, typename... Args>
        -: 1624:    struct IsPointerToTypeDerivedFromQObject<Result(*)(Args...)> { enum { Value = false }; };
        -: 1625:#endif
        -: 1626:
        -: 1627:    template<typename T>
        -: 1628:    struct QMetaTypeTypeFlags
        -: 1629:    {
        -: 1630:        enum { Flags = (QTypeInfoQuery<T>::isRelocatable ? QMetaType::MovableType : 0)
        -: 1631:                     | (QTypeInfo<T>::isComplex ? QMetaType::NeedsConstruction : 0)
        -: 1632:                     | (QTypeInfo<T>::isComplex ? QMetaType::NeedsDestruction : 0)
        -: 1633:                     | (IsPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::PointerToQObject : 0)
        -: 1634:                     | (IsSharedPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::SharedPointerToQObject : 0)
        -: 1635:                     | (IsWeakPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::WeakPointerToQObject : 0)
        -: 1636:                     | (IsTrackingPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::TrackingPointerToQObject : 0)
        -: 1637:                     | (Q_IS_ENUM(T) ? QMetaType::IsEnumeration : 0)
        -: 1638:                     | (IsGadgetHelper<T>::Value ? QMetaType::IsGadget : 0)
        -: 1639:             };
        -: 1640:    };
        -: 1641:
        -: 1642:    template<typename T, bool defined>
        -: 1643:    struct MetaTypeDefinedHelper
        -: 1644:    {
        -: 1645:        enum DefinedType { Defined = defined };
        -: 1646:    };
        -: 1647:
        -: 1648:    template<typename SmartPointer>
        -: 1649:    struct QSmartPointerConvertFunctor
        -: 1650:    {
        -: 1651:        QObject* operator()(const SmartPointer &p) const
        -: 1652:        {
        -: 1653:            return p.operator->();
        -: 1654:        }
        -: 1655:    };
        -: 1656:
        -: 1657:    template<typename T>
        -: 1658:    struct QSmartPointerConvertFunctor<QWeakPointer<T> >
        -: 1659:    {
        -: 1660:        QObject* operator()(const QWeakPointer<T> &p) const
        -: 1661:        {
        -: 1662:            return p.data();
        -: 1663:        }
        -: 1664:    };
        -: 1665:}
        -: 1666:
        -: 1667:template <typename T>
        -: 1668:int qRegisterNormalizedMetaType(const QT_PREPEND_NAMESPACE(QByteArray) &normalizedTypeName
        -: 1669:#ifndef Q_QDOC
        -: 1670:    , T * dummy = 0
        -: 1671:    , typename QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::DefinedType defined = QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::Defined
        -: 1672:#endif
        -: 1673:)
        -: 1674:{
        -: 1675:#ifndef QT_NO_QOBJECT
        -: 1676:    Q_ASSERT_X(normalizedTypeName == QMetaObject::normalizedType(normalizedTypeName.constData()), "qRegisterNormalizedMetaType", "qRegisterNormalizedMetaType was called with a not normalized type name, please call qRegisterMetaType instead.");
        -: 1677:#endif
        -: 1678:    const int typedefOf = dummy ? -1 : QtPrivate::QMetaTypeIdHelper<T>::qt_metatype_id();
        -: 1679:    if (typedefOf != -1)
        -: 1680:        return QMetaType::registerNormalizedTypedef(normalizedTypeName, typedefOf);
        -: 1681:
        -: 1682:    QMetaType::TypeFlags flags(QtPrivate::QMetaTypeTypeFlags<T>::Flags);
        -: 1683:
        -: 1684:    if (defined)
        -: 1685:        flags |= QMetaType::WasDeclaredAsMetaType;
        -: 1686:
        -: 1687:    const int id = QMetaType::registerNormalizedType(normalizedTypeName,
        -: 1688:                                   QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Destruct,
        -: 1689:                                   QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Construct,
        -: 1690:                                   int(sizeof(T)),
        -: 1691:                                   flags,
        -: 1692:                                   QtPrivate::MetaObjectForType<T>::value());
        -: 1693:
        -: 1694:    if (id > 0) {
        -: 1695:        QtPrivate::SequentialContainerConverterHelper<T>::registerConverter(id);
        -: 1696:        QtPrivate::AssociativeContainerConverterHelper<T>::registerConverter(id);
        -: 1697:        QtPrivate::MetaTypePairHelper<T>::registerConverter(id);
        -: 1698:        QtPrivate::MetaTypeSmartPointerHelper<T>::registerConverter(id);
        -: 1699:    }
        -: 1700:
        -: 1701:    return id;
        -: 1702:}
        -: 1703:
        -: 1704:template <typename T>
        -: 1705:int qRegisterMetaType(const char *typeName
        -: 1706:#ifndef Q_QDOC
        -: 1707:    , T * dummy = Q_NULLPTR
        -: 1708:    , typename QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::DefinedType defined = QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::Defined
        -: 1709:#endif
        -: 1710:)
        -: 1711:{
        -: 1712:#ifdef QT_NO_QOBJECT
        -: 1713:    QT_PREPEND_NAMESPACE(QByteArray) normalizedTypeName = typeName;
        -: 1714:#else
        -: 1715:    QT_PREPEND_NAMESPACE(QByteArray) normalizedTypeName = QMetaObject::normalizedType(typeName);
        -: 1716:#endif
        -: 1717:    return qRegisterNormalizedMetaType<T>(normalizedTypeName, dummy, defined);
        -: 1718:}
        -: 1719:
        -: 1720:#ifndef QT_NO_DATASTREAM
        -: 1721:template <typename T>
        -: 1722:void qRegisterMetaTypeStreamOperators(const char *typeName
        -: 1723:#ifndef Q_QDOC
        -: 1724:    , T * /* dummy */ = Q_NULLPTR
        -: 1725:#endif
        -: 1726:)
        -: 1727:{
        -: 1728:    qRegisterMetaType<T>(typeName);
        -: 1729:    QMetaType::registerStreamOperators(typeName, QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Save,
        -: 1730:                                                 QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Load);
        -: 1731:}
        -: 1732:#endif // QT_NO_DATASTREAM
        -: 1733:
        -: 1734:template <typename T>
        -: 1735:inline Q_DECL_CONSTEXPR int qMetaTypeId()
        -: 1736:{
        -: 1737:    Q_STATIC_ASSERT_X(QMetaTypeId2<T>::Defined, "Type is not registered, please use the Q_DECLARE_METATYPE macro to make it known to Qt's meta-object system");
        -: 1738:    return QMetaTypeId2<T>::qt_metatype_id();
        -: 1739:}
        -: 1740:
        -: 1741:template <typename T>
        -: 1742:inline Q_DECL_CONSTEXPR int qRegisterMetaType()
        -: 1743:{
        -: 1744:    return qMetaTypeId<T>();
        -: 1745:}
        -: 1746:
        -: 1747:#if QT_DEPRECATED_SINCE(5, 1) && !defined(Q_QDOC)
        -: 1748:// There used to be a T *dummy = 0 argument in Qt 4.0 to support MSVC6
        -: 1749:template <typename T>
        -: 1750:QT_DEPRECATED inline Q_DECL_CONSTEXPR int qMetaTypeId(T *)
        -: 1751:{ return qMetaTypeId<T>(); }
        -: 1752:#ifndef Q_CC_SUN
        -: 1753:template <typename T>
        -: 1754:QT_DEPRECATED inline Q_DECL_CONSTEXPR int qRegisterMetaType(T *)
        -: 1755:{ return qRegisterMetaType<T>(); }
        -: 1756:#endif
        -: 1757:#endif
        -: 1758:
        -: 1759:#ifndef QT_NO_QOBJECT
        -: 1760:template <typename T>
        -: 1761:struct QMetaTypeIdQObject<T*, QMetaType::PointerToQObject>
        -: 1762:{
        -: 1763:    enum {
        -: 1764:        Defined = 1
        -: 1765:    };
        -: 1766:
        -: 1767:    static int qt_metatype_id()
        -: 1768:    {
        -: 1769:        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);
        -: 1770:        if (const int id = metatype_id.loadAcquire())
        -: 1771:            return id;
        -: 1772:        const char * const cName = T::staticMetaObject.className();
        -: 1773:        QByteArray typeName;
        -: 1774:        typeName.reserve(int(strlen(cName)) + 1);
        -: 1775:        typeName.append(cName).append('*');
        -: 1776:        const int newId = qRegisterNormalizedMetaType<T*>(
        -: 1777:                        typeName,
        -: 1778:                        reinterpret_cast<T**>(quintptr(-1)));
        -: 1779:        metatype_id.storeRelease(newId);
        -: 1780:        return newId;
        -: 1781:    }
        -: 1782:};
        -: 1783:
        -: 1784:template <typename T>
        -: 1785:struct QMetaTypeIdQObject<T, QMetaType::IsGadget>
        -: 1786:{
        -: 1787:    enum {
        -: 1788:        Defined = QtPrivate::is_default_constructible<T>::value
        -: 1789:    };
        -: 1790:
        -: 1791:    static int qt_metatype_id()
        -: 1792:    {
        -: 1793:        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);
        -: 1794:        if (const int id = metatype_id.loadAcquire())
        -: 1795:            return id;
        -: 1796:        const char * const cName = T::staticMetaObject.className();
        -: 1797:        const int newId = qRegisterNormalizedMetaType<T>(
        -: 1798:            cName,
        -: 1799:            reinterpret_cast<T*>(quintptr(-1)));
        -: 1800:        metatype_id.storeRelease(newId);
        -: 1801:        return newId;
        -: 1802:    }
        -: 1803:};
        -: 1804:
        -: 1805:template <typename T>
        -: 1806:struct QMetaTypeIdQObject<T, QMetaType::IsEnumeration>
        -: 1807:{
        -: 1808:    enum {
        -: 1809:        Defined = 1
        -: 1810:    };
        -: 1811:
        -: 1812:    static int qt_metatype_id()
        -: 1813:    {
        -: 1814:        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);
        -: 1815:        if (const int id = metatype_id.loadAcquire())
        -: 1816:            return id;
        -: 1817:        const char *eName = qt_getEnumName(T());
        -: 1818:        const char *cName = qt_getEnumMetaObject(T())->className();
        -: 1819:        QByteArray typeName;
        -: 1820:        typeName.reserve(int(strlen(cName) + 2 + strlen(eName)));
        -: 1821:        typeName.append(cName).append("::").append(eName);
        -: 1822:        const int newId = qRegisterNormalizedMetaType<T>(
        -: 1823:            typeName,
        -: 1824:            reinterpret_cast<T*>(quintptr(-1)));
        -: 1825:        metatype_id.storeRelease(newId);
        -: 1826:        return newId;
        -: 1827:    }
        -: 1828:};
        -: 1829:#endif
        -: 1830:
        -: 1831:#ifndef QT_NO_DATASTREAM
        -: 1832:template <typename T>
        -: 1833:inline int qRegisterMetaTypeStreamOperators()
        -: 1834:{
        -: 1835:    int id = qMetaTypeId<T>();
        -: 1836:    QMetaType::registerStreamOperators(id, QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Save,
        -: 1837:                                           QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Load);
        -: 1838:    return id;
        -: 1839:}
        -: 1840:#endif
        -: 1841:
        -: 1842:#define Q_DECLARE_OPAQUE_POINTER(POINTER)                               \
        -: 1843:    QT_BEGIN_NAMESPACE namespace QtPrivate {                            \
        -: 1844:        template <>                                                     \
        -: 1845:        struct IsPointerToTypeDerivedFromQObject<POINTER >              \
        -: 1846:        {                                                               \
        -: 1847:            enum { Value = false };                                     \
        -: 1848:        };                                                              \
        -: 1849:    } QT_END_NAMESPACE                                                  \
        -: 1850:    /**/
        -: 1851:
        -: 1852:#define Q_DECLARE_METATYPE(TYPE) Q_DECLARE_METATYPE_IMPL(TYPE)
        -: 1853:#define Q_DECLARE_METATYPE_IMPL(TYPE)                                   \
        -: 1854:    QT_BEGIN_NAMESPACE                                                  \
        -: 1855:    template <>                                                         \
        -: 1856:    struct QMetaTypeId< TYPE >                                          \
        -: 1857:    {                                                                   \
        -: 1858:        enum { Defined = 1 };                                           \
        -: 1859:        static int qt_metatype_id()                                     \
        -: 1860:            {                                                           \
        -: 1861:                static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
        -: 1862:                if (const int id = metatype_id.loadAcquire())           \
        -: 1863:                    return id;                                          \
        -: 1864:                const int newId = qRegisterMetaType< TYPE >(#TYPE,      \
        -: 1865:                              reinterpret_cast< TYPE *>(quintptr(-1))); \
        -: 1866:                metatype_id.storeRelease(newId);                        \
        -: 1867:                return newId;                                           \
        -: 1868:            }                                                           \
        -: 1869:    };                                                                  \
        -: 1870:    QT_END_NAMESPACE
        -: 1871:
        -: 1872:
        -: 1873:#define Q_DECLARE_BUILTIN_METATYPE(TYPE, METATYPEID, NAME) \
        -: 1874:    QT_BEGIN_NAMESPACE \
        -: 1875:    template<> struct QMetaTypeId2<NAME> \
        -: 1876:    { \
        -: 1877:        enum { Defined = 1, IsBuiltIn = true, MetaType = METATYPEID };   \
        -: 1878:        static inline Q_DECL_CONSTEXPR int qt_metatype_id() { return METATYPEID; } \
        -: 1879:    }; \
        -: 1880:    QT_END_NAMESPACE
        -: 1881:
        -: 1882:#define QT_FORWARD_DECLARE_STATIC_TYPES_ITER(TypeName, TypeId, Name) \
        -: 1883:    class Name;
        -: 1884:
        -: 1885:QT_FOR_EACH_STATIC_CORE_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)
        -: 1886:QT_FOR_EACH_STATIC_GUI_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)
        -: 1887:QT_FOR_EACH_STATIC_WIDGETS_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)
        -: 1888:
        -: 1889:#undef QT_FORWARD_DECLARE_STATIC_TYPES_ITER
        -: 1890:
        -: 1891:typedef QList<QVariant> QVariantList;
        -: 1892:typedef QMap<QString, QVariant> QVariantMap;
        -: 1893:typedef QHash<QString, QVariant> QVariantHash;
        -: 1894:typedef QList<QByteArray> QByteArrayList;
        -: 1895:
        -: 1896:#define Q_DECLARE_METATYPE_TEMPLATE_1ARG(SINGLE_ARG_TEMPLATE) \
        -: 1897:QT_BEGIN_NAMESPACE \
        -: 1898:template <typename T> \
        -: 1899:struct QMetaTypeId< SINGLE_ARG_TEMPLATE<T> > \
        -: 1900:{ \
        -: 1901:    enum { \
        -: 1902:        Defined = QMetaTypeId2<T>::Defined \
        -: 1903:    }; \
        -: 1904:    static int qt_metatype_id() \
        -: 1905:    { \
        -: 1906:        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
        -: 1907:        if (const int id = metatype_id.load()) \
        -: 1908:            return id; \
        -: 1909:        const char *tName = QMetaType::typeName(qMetaTypeId<T>()); \
        -: 1910:        Q_ASSERT(tName); \
        -: 1911:        const int tNameLen = int(qstrlen(tName)); \
        -: 1912:        QByteArray typeName; \
        -: 1913:        typeName.reserve(int(sizeof(#SINGLE_ARG_TEMPLATE)) + 1 + tNameLen + 1 + 1); \
        -: 1914:        typeName.append(#SINGLE_ARG_TEMPLATE, int(sizeof(#SINGLE_ARG_TEMPLATE)) - 1) \
        -: 1915:            .append('<').append(tName, tNameLen); \
        -: 1916:        if (typeName.endsWith('>')) \
        -: 1917:            typeName.append(' '); \
        -: 1918:        typeName.append('>'); \
        -: 1919:        const int newId = qRegisterNormalizedMetaType< SINGLE_ARG_TEMPLATE<T> >( \
        -: 1920:                        typeName, \
        -: 1921:                        reinterpret_cast< SINGLE_ARG_TEMPLATE<T> *>(quintptr(-1))); \
        -: 1922:        metatype_id.storeRelease(newId); \
        -: 1923:        return newId; \
        -: 1924:    } \
        -: 1925:}; \
        -: 1926:namespace QtPrivate { \
        -: 1927:template<typename T> \
        -: 1928:struct IsSequentialContainer<SINGLE_ARG_TEMPLATE<T> > \
        -: 1929:{ \
        -: 1930:    enum { Value = true }; \
        -: 1931:}; \
        -: 1932:} \
        -: 1933:QT_END_NAMESPACE
        -: 1934:
        -: 1935:#define Q_DECLARE_METATYPE_TEMPLATE_2ARG(DOUBLE_ARG_TEMPLATE) \
        -: 1936:QT_BEGIN_NAMESPACE \
        -: 1937:template<typename T, typename U> \
        -: 1938:struct QMetaTypeId< DOUBLE_ARG_TEMPLATE<T, U> > \
        -: 1939:{ \
        -: 1940:    enum { \
        -: 1941:        Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined \
        -: 1942:    }; \
        -: 1943:    static int qt_metatype_id() \
        -: 1944:    { \
        -: 1945:        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
        -: 1946:        if (const int id = metatype_id.loadAcquire()) \
        -: 1947:            return id; \
        -: 1948:        const char *tName = QMetaType::typeName(qMetaTypeId<T>()); \
        -: 1949:        const char *uName = QMetaType::typeName(qMetaTypeId<U>()); \
        -: 1950:        Q_ASSERT(tName); \
        -: 1951:        Q_ASSERT(uName); \
        -: 1952:        const int tNameLen = int(qstrlen(tName)); \
        -: 1953:        const int uNameLen = int(qstrlen(uName)); \
        -: 1954:        QByteArray typeName; \
        -: 1955:        typeName.reserve(int(sizeof(#DOUBLE_ARG_TEMPLATE)) + 1 + tNameLen + 1 + uNameLen + 1 + 1); \
        -: 1956:        typeName.append(#DOUBLE_ARG_TEMPLATE, int(sizeof(#DOUBLE_ARG_TEMPLATE)) - 1) \
        -: 1957:            .append('<').append(tName, tNameLen).append(',').append(uName, uNameLen); \
        -: 1958:        if (typeName.endsWith('>')) \
        -: 1959:            typeName.append(' '); \
        -: 1960:        typeName.append('>'); \
        -: 1961:        const int newId = qRegisterNormalizedMetaType< DOUBLE_ARG_TEMPLATE<T, U> >(\
        -: 1962:                        typeName, \
        -: 1963:                        reinterpret_cast< DOUBLE_ARG_TEMPLATE<T, U> *>(quintptr(-1))); \
        -: 1964:        metatype_id.storeRelease(newId); \
        -: 1965:        return newId; \
        -: 1966:    } \
        -: 1967:}; \
        -: 1968:QT_END_NAMESPACE
        -: 1969:
        -: 1970:namespace QtPrivate {
        -: 1971:
        -: 1972:template<typename T, bool /* isSharedPointerToQObjectDerived */ = false>
        -: 1973:struct SharedPointerMetaTypeIdHelper
        -: 1974:{
        -: 1975:    enum {
        -: 1976:        Defined = 0
        -: 1977:    };
        -: 1978:    static int qt_metatype_id()
        -: 1979:    {
        -: 1980:        return -1;
        -: 1981:    }
        -: 1982:};
        -: 1983:
        -: 1984:}
        -: 1985:
        -: 1986:#define Q_DECLARE_SMART_POINTER_METATYPE(SMART_POINTER) \
        -: 1987:QT_BEGIN_NAMESPACE \
        -: 1988:namespace QtPrivate { \
        -: 1989:template<typename T> \
        -: 1990:struct SharedPointerMetaTypeIdHelper<SMART_POINTER<T>, true> \
        -: 1991:{ \
        -: 1992:    enum { \
        -: 1993:        Defined = 1 \
        -: 1994:    }; \
        -: 1995:    static int qt_metatype_id() \
        -: 1996:    { \
        -: 1997:        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
        -: 1998:        if (const int id = metatype_id.loadAcquire()) \
        -: 1999:            return id; \
        -: 2000:        const char * const cName = T::staticMetaObject.className(); \
        -: 2001:        QByteArray typeName; \
        -: 2002:        typeName.reserve(int(sizeof(#SMART_POINTER) + 1 + strlen(cName) + 1)); \
        -: 2003:        typeName.append(#SMART_POINTER, int(sizeof(#SMART_POINTER)) - 1) \
        -: 2004:            .append('<').append(cName).append('>'); \
        -: 2005:        const int newId = qRegisterNormalizedMetaType< SMART_POINTER<T> >( \
        -: 2006:                        typeName, \
        -: 2007:                        reinterpret_cast< SMART_POINTER<T> *>(quintptr(-1))); \
        -: 2008:        metatype_id.storeRelease(newId); \
        -: 2009:        return newId; \
        -: 2010:    } \
        -: 2011:}; \
        -: 2012:template<typename T> \
        -: 2013:struct MetaTypeSmartPointerHelper<SMART_POINTER<T> , \
        -: 2014:        typename QEnableIf<IsPointerToTypeDerivedFromQObject<T*>::Value >::Type> \
        -: 2015:{ \
        -: 2016:    static bool registerConverter(int id) \
        -: 2017:    { \
        -: 2018:        const int toId = QMetaType::QObjectStar; \
        -: 2019:        if (!QMetaType::hasRegisteredConverterFunction(id, toId)) { \
        -: 2020:            QtPrivate::QSmartPointerConvertFunctor<SMART_POINTER<T> > o; \
        -: 2021:            static const QtPrivate::ConverterFunctor<SMART_POINTER<T>, \
        -: 2022:                                    QObject*, \
        -: 2023:                                    QSmartPointerConvertFunctor<SMART_POINTER<T> > > f(o); \
        -: 2024:            return QMetaType::registerConverterFunction(&f, id, toId); \
        -: 2025:        } \
        -: 2026:        return true; \
        -: 2027:    } \
        -: 2028:}; \
        -: 2029:} \
        -: 2030:template <typename T> \
        -: 2031:struct QMetaTypeId< SMART_POINTER<T> > \
        -: 2032:    : QtPrivate::SharedPointerMetaTypeIdHelper< SMART_POINTER<T>, \
        -: 2033:                                                QtPrivate::IsPointerToTypeDerivedFromQObject<T*>::Value> \
        -: 2034:{ \
        -: 2035:};\
        -: 2036:QT_END_NAMESPACE
        -: 2037:
        -: 2038:#define Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE_ITER(TEMPLATENAME) \
        -: 2039:    QT_BEGIN_NAMESPACE \
        -: 2040:    template <class T> class TEMPLATENAME; \
        -: 2041:    QT_END_NAMESPACE \
        -: 2042:    Q_DECLARE_METATYPE_TEMPLATE_1ARG(TEMPLATENAME)
        -: 2043:
        -: 2044:QT_END_NAMESPACE
        -: 2045:
        -: 2046:QT_FOR_EACH_AUTOMATIC_TEMPLATE_1ARG(Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE_ITER)
        -: 2047:
        -: 2048:#undef Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE_ITER
        -: 2049:
        -: 2050:#define Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE Q_DECLARE_METATYPE_TEMPLATE_1ARG
        -: 2051:
        -: 2052:Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::vector)
        -: 2053:Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::list)
        -: 2054:
        -: 2055:#define Q_FORWARD_DECLARE_METATYPE_TEMPLATE_2ARG_ITER(TEMPLATENAME, CPPTYPE) \
        -: 2056:    QT_BEGIN_NAMESPACE \
        -: 2057:    template <class T1, class T2> CPPTYPE TEMPLATENAME; \
        -: 2058:    QT_END_NAMESPACE \
        -: 2059:
        -: 2060:QT_FOR_EACH_AUTOMATIC_TEMPLATE_2ARG(Q_FORWARD_DECLARE_METATYPE_TEMPLATE_2ARG_ITER)
        -: 2061:
        -: 2062:#undef Q_DECLARE_METATYPE_TEMPLATE_2ARG_ITER
        -: 2063:
        -: 2064:#define Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(TEMPLATENAME) \
        -: 2065:    QT_BEGIN_NAMESPACE \
        -: 2066:    namespace QtPrivate { \
        -: 2067:    template<typename T, typename U> \
        -: 2068:    struct IsAssociativeContainer<TEMPLATENAME<T, U> > \
        -: 2069:    { \
        -: 2070:        enum { Value = true }; \
        -: 2071:    }; \
        -: 2072:    } \
        -: 2073:    QT_END_NAMESPACE \
        -: 2074:    Q_DECLARE_METATYPE_TEMPLATE_2ARG(TEMPLATENAME)
        -: 2075:
        -: 2076:Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(QHash)
        -: 2077:Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(QMap)
        -: 2078:Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::map)
        -: 2079:
        -: 2080:Q_DECLARE_METATYPE_TEMPLATE_2ARG(QPair)
        -: 2081:Q_DECLARE_METATYPE_TEMPLATE_2ARG(std::pair)
        -: 2082:
        -: 2083:#define Q_DECLARE_METATYPE_TEMPLATE_SMART_POINTER_ITER(TEMPLATENAME) \
        -: 2084:    Q_DECLARE_SMART_POINTER_METATYPE(TEMPLATENAME)
        -: 2085:
        -: 2086:
        -: 2087:QT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(Q_DECLARE_METATYPE_TEMPLATE_SMART_POINTER_ITER)
        -: 2088:
        -: 2089:QT_BEGIN_NAMESPACE
        -: 2090:
        -: 2091:#undef Q_DECLARE_METATYPE_TEMPLATE_SMART_POINTER_ITER
        -: 2092:
        -: 2093:inline QMetaType::QMetaType(const ExtensionFlag extensionFlags, const QMetaTypeInterface *info,
        -: 2094:                            Creator creator,
        -: 2095:                            Deleter deleter,
        -: 2096:                            SaveOperator saveOp,
        -: 2097:                            LoadOperator loadOp,
        -: 2098:                            Constructor constructor,
        -: 2099:                            Destructor destructor,
        -: 2100:                            uint size,
        -: 2101:                            uint theTypeFlags,
        -: 2102:                            int typeId,
        -: 2103:                            const QMetaObject *_metaObject)
        -: 2104:    : m_creator_unused(creator)
        -: 2105:    , m_deleter_unused(deleter)
        -: 2106:    , m_saveOp(saveOp)
        -: 2107:    , m_loadOp(loadOp)
        -: 2108:    , m_constructor(constructor)
        -: 2109:    , m_destructor(destructor)
        -: 2110:    , m_extension(Q_NULLPTR)
        -: 2111:    , m_size(size)
        -: 2112:    , m_typeFlags(theTypeFlags)
        -: 2113:    , m_extensionFlags(extensionFlags)
        -: 2114:    , m_typeId(typeId)
        -: 2115:    , m_metaObject(_metaObject)
        -: 2116:{
        -: 2117:    if (Q_UNLIKELY(isExtended(CtorEx) || typeId == QMetaType::Void))
        -: 2118:        ctor(info);
        -: 2119:}
        -: 2120:
        -: 2121:inline QMetaType::~QMetaType()
        -: 2122:{
        -: 2123:    if (Q_UNLIKELY(isExtended(DtorEx)))
        -: 2124:        dtor();
        -: 2125:}
        -: 2126:
        -: 2127:inline bool QMetaType::isValid() const
        -: 2128:{
        -: 2129:    return m_typeId != UnknownType;
        -: 2130:}
        -: 2131:
        -: 2132:inline bool QMetaType::isRegistered() const
        -: 2133:{
        -: 2134:    return isValid();
        -: 2135:}
        -: 2136:
        -: 2137:inline void *QMetaType::create(const void *copy) const
        -: 2138:{
        -: 2139:    // ### TODO Qt6 remove the extension
        -: 2140:    return createExtended(copy);
        -: 2141:}
        -: 2142:
        -: 2143:inline void QMetaType::destroy(void *data) const
        -: 2144:{
        -: 2145:    // ### TODO Qt6 remove the extension
        -: 2146:    destroyExtended(data);
        -: 2147:}
        -: 2148:
        -: 2149:inline void *QMetaType::construct(void *where, const void *copy) const
        -: 2150:{
        -: 2151:    if (Q_UNLIKELY(isExtended(ConstructEx)))
        -: 2152:        return constructExtended(where, copy);
        -: 2153:    return m_constructor(where, copy);
        -: 2154:}
        -: 2155:
        -: 2156:inline void QMetaType::destruct(void *data) const
        -: 2157:{
        -: 2158:    if (Q_UNLIKELY(isExtended(DestructEx)))
        -: 2159:        return destructExtended(data);
        -: 2160:    if (Q_UNLIKELY(!data))
        -: 2161:        return;
        -: 2162:    m_destructor(data);
        -: 2163:}
        -: 2164:
        -: 2165:inline int QMetaType::sizeOf() const
        -: 2166:{
        -: 2167:    if (Q_UNLIKELY(isExtended(SizeEx)))
        -: 2168:        return sizeExtended();
        -: 2169:    return m_size;
        -: 2170:}
        -: 2171:
        -: 2172:inline QMetaType::TypeFlags QMetaType::flags() const
        -: 2173:{
        -: 2174:    if (Q_UNLIKELY(isExtended(FlagsEx)))
        -: 2175:        return flagsExtended();
        -: 2176:    return QMetaType::TypeFlags(m_typeFlags);
        -: 2177:}
        -: 2178:
        -: 2179:inline const QMetaObject *QMetaType::metaObject() const
        -: 2180:{
        -: 2181:    if (Q_UNLIKELY(isExtended(MetaObjectEx)))
        -: 2182:        return metaObjectExtended();
        -: 2183:    return m_metaObject;
        -: 2184:}
        -: 2185:
        -: 2186:QT_END_NAMESPACE
        -: 2187:
        -: 2188:
    #####: 2189:QT_FOR_EACH_STATIC_TYPE(Q_DECLARE_BUILTIN_METATYPE)
        -: 2190:
        -: 2191:Q_DECLARE_METATYPE(QtMetaTypePrivate::QSequentialIterableImpl)
        -: 2192:Q_DECLARE_METATYPE(QtMetaTypePrivate::QAssociativeIterableImpl)
        -: 2193:Q_DECLARE_METATYPE(QtMetaTypePrivate::QPairVariantInterfaceImpl)
        -: 2194:
        -: 2195:QT_BEGIN_NAMESPACE
        -: 2196:
        -: 2197:template <typename T>
        -: 2198:inline bool QtPrivate::IsMetaTypePair<T, true>::registerConverter(int id)
        -: 2199:{
        -: 2200:    const int toId = qMetaTypeId<QtMetaTypePrivate::QPairVariantInterfaceImpl>();
        -: 2201:    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
        -: 2202:        QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor<T> o;
        -: 2203:        static const QtPrivate::ConverterFunctor<T,
        -: 2204:                                    QtMetaTypePrivate::QPairVariantInterfaceImpl,
        -: 2205:                                    QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor<T> > f(o);
        -: 2206:        return QMetaType::registerConverterFunction(&f, id, toId);
        -: 2207:    }
        -: 2208:    return true;
        -: 2209:}
        -: 2210:
        -: 2211:namespace QtPrivate {
        -: 2212:    template<typename T>
        -: 2213:    struct ValueTypeIsMetaType<T, true>
        -: 2214:    {
        -: 2215:        static bool registerConverter(int id)
        -: 2216:        {
        -: 2217:            const int toId = qMetaTypeId<QtMetaTypePrivate::QSequentialIterableImpl>();
        -: 2218:            if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
        -: 2219:                QtMetaTypePrivate::QSequentialIterableConvertFunctor<T> o;
        -: 2220:                static const QtPrivate::ConverterFunctor<T,
        -: 2221:                        QtMetaTypePrivate::QSequentialIterableImpl,
        -: 2222:                QtMetaTypePrivate::QSequentialIterableConvertFunctor<T> > f(o);
        -: 2223:                return QMetaType::registerConverterFunction(&f, id, toId);
        -: 2224:            }
        -: 2225:            return true;
        -: 2226:        }
        -: 2227:    };
        -: 2228:
        -: 2229:    template<typename T>
        -: 2230:    struct AssociativeValueTypeIsMetaType<T, true>
        -: 2231:    {
        -: 2232:        static bool registerConverter(int id)
        -: 2233:        {
        -: 2234:            const int toId = qMetaTypeId<QtMetaTypePrivate::QAssociativeIterableImpl>();
        -: 2235:            if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
        -: 2236:                QtMetaTypePrivate::QAssociativeIterableConvertFunctor<T> o;
        -: 2237:                static const QtPrivate::ConverterFunctor<T,
        -: 2238:                                            QtMetaTypePrivate::QAssociativeIterableImpl,
        -: 2239:                                            QtMetaTypePrivate::QAssociativeIterableConvertFunctor<T> > f(o);
        -: 2240:                return QMetaType::registerConverterFunction(&f, id, toId);
        -: 2241:            }
        -: 2242:            return true;
        -: 2243:        }
        -: 2244:    };
        -: 2245:}
        -: 2246:
        -: 2247:QT_END_NAMESPACE
        -: 2248:
        -: 2249:#endif // QMETATYPE_H
